<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Master Display System Generator - Interactive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* LCARS Color Palette */
        :root {
            --lcars-orange: #FF9C00;
            --lcars-pink: #CC6699;
            --lcars-blue: #9999FF;
            --lcars-purple: #CC99CC;
            --lcars-red: #CC6666;
            --lcars-yellow: #FFCC66;
            --lcars-tan: #FFCC99;
            --lcars-skyblue: #6699CC;
            --lcars-peach: #FF9966;
            --lcars-bg: #000000;
            --lcars-text: #FFFFFF;
        }

        /* Sidebar Controls */
        .sidebar {
            /* Use percentage so sidebar keeps relative proportion on wide screens */
            flex: 0 0 20%;
            width: 20%;
            min-width: 220px; /* keep usable */
            max-width: 420px;
            background: #111;
            padding: 20px;
            overflow-y: auto;
            border-right: 3px solid var(--lcars-blue);
            transition: transform 0.3s ease;
            position: relative;
            z-index: 1000;
        }

        /* Mobile menu toggle */
        .menu-toggle {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 10001;
            background: var(--lcars-orange);
            color: #000;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-weight: bold;
        }

        /* Ensure top/bottom UI and canvas controls remain visible above canvas
           and other layout changes on all screen sizes. This raises z-index so
           the toolbar/status/controls don't get visually hidden by transforms. */
        .toolbar, .status-bar, .canvas-controls, .menu-toggle {
            z-index: 11000 !important;
        }

        .menu-toggle:hover {
            background: var(--lcars-yellow);
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                transform: translateX(-100%);
                box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 60px;
                transition: transform 0.3s ease;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .menu-toggle.sidebar-open {
                background: var(--lcars-red);
            }

            .canvas-area {
                width: 100%;
            }
            
            .sidebar h1 {
                padding-right: 60px;
            }
        }

        .sidebar h1 {
            color: var(--lcars-blue);
            font-size: 24px;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .sidebar h2 {
            color: var(--lcars-orange);
            font-size: 18px;
            margin: 20px 0 10px 0;
            padding-top: 15px;
            border-top: 2px solid var(--lcars-blue);
        }

        .sidebar h2.primary {
            color: var(--lcars-orange);
            border-top-color: var(--lcars-orange);
        }

        .sidebar h2.secondary {
            color: var(--lcars-purple);
            border-top-color: var(--lcars-purple);
        }

        .sidebar h2.accordion {
            cursor: pointer;
            position: relative;
            padding-right: 30px;
            user-select: none;
        }

        .sidebar h2.accordion::after {
            content: '‚ñº';
            position: absolute;
            right: 5px;
            font-size: 14px;
            transition: transform 0.3s;
        }

        .sidebar h2.accordion.collapsed::after {
            transform: rotate(-90deg);
        }

        .accordion-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
        }

        .accordion-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: var(--lcars-skyblue);
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .control-group input,
        .control-group select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid var(--lcars-blue);
            color: #fff;
            font-size: 14px;
            border-radius: 4px;
        }

        .control-group input[type="color"] {
            height: 40px;
            cursor: pointer;
        }

        .control-group input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .btn {
            padding: 10px 20px;
            background: var(--lcars-orange);
            color: #000;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            margin: 5px 5px 5px 0;
            transition: background 0.3s;
        }

        .btn:hover {
            background: var(--lcars-yellow);
        }

        .btn-secondary {
            background: var(--lcars-blue);
        }
        .btn-secondary:hover {
            background: var(--lcars-skyblue);
        }

        .btn-danger {
            background: var(--lcars-red);
            color: #fff;
        }

        /* Main Canvas Area */
        .canvas-area {
            flex: 1 1 80%;
            display: flex;
            flex-direction: column;
            background: #000;
        }

        /* Canvas controls (zoom, pan toggle) ‚Äî inline inside status bar row
           but visually floated above the canvas so they never overlap text. */
        .canvas-controls {
            position: fixed;
            right: 12px;
            bottom: 8px;
            display: inline-flex;
            gap: 8px;
            align-items: center;
            z-index: 10050;
            pointer-events: auto;
            margin-left: 0;
        }

        .canvas-control-btn {
            padding: 10px;
            background: rgba(10,10,10,0.8);
            color: var(--lcars-orange);
            border: 1px solid var(--lcars-blue);
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            min-width: 44px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

          .canvas-control-btn.clicked { transform: scale(0.95); }
          /* Use #A66500 as a muted non-hover color with modest transparency, and slightly stronger on hover.
              Keep the active color as the bright LCARS orange. */
          .canvas-control-btn { background: rgba(166,101,0,0.18); color: #A66500; }
          .canvas-control-btn:hover { background: rgba(166,101,0,0.36); color: #A66500; }
          .canvas-control-btn.active { background: var(--lcars-orange); color: #000; }

        /* Touch-hold overlay (circular progress shown under finger while holding) */
        .touch-hold-overlay {
            position: fixed;
            width: 64px;
            height: 64px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 12000;
            display: none;
            opacity: 0.95;
        }

        .toolbar {
            position: fixed;
            top: 6px;
            right: 6px;
            background: transparent; /* remove gray background so help button stands alone */
            padding: 6px; /* small padding to allow compact tab placement */
            border-radius: 8px;
            border: none;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10002;
        }
        
        .toolbar-row-1,
        .toolbar-row-2 {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        /* Help button compact style: show label on hover. Match deck-tab styling (light purple), small padding. */
        .help-tab-btn { display: inline-flex; align-items: center; gap: 6px; padding: 5px; background: var(--lcars-purple); border: 1px solid var(--lcars-blue); border-radius: 8px; color: #000; cursor: pointer; }
        .help-tab-btn .help-icon { display: inline-block; font-size: 14px; line-height: 1; }
        .help-tab-btn .help-label { display:inline-block; opacity:0; width:0; overflow:hidden; transition: width 140ms ease, opacity 140ms ease; white-space: nowrap; color: #000; font-weight: bold; }
        .help-tab-btn:hover { background: #e8d6f0; }
        .help-tab-btn:hover .help-label { opacity:1; width:44px; margin-left:6px; }

            .canvas-container {
                flex: 1;
                overflow: auto;
                position: relative;
                z-index: 1;
                /* Remove vertical padding so the SVG border sits at the outermost pixels
                    (no extra top/bottom whitespace). Keep horizontal padding for layout. */
                padding: 0 20px;
                display: flex;
                justify-content: center;
                align-items: center;
                /* The SVG's size is controlled by its own attributes and rendering logic.
                    Do not constrain the canvas container by viewport size ‚Äî keep overflow
                    so users on smaller screens can scroll, and large screens won't force
                    the SVG to scale. */
                margin: 0 auto;
          }

        #mdsCanvas {
            display: block;
            box-sizing: border-box;
            margin: 0;
            border: 2px solid var(--lcars-blue);
            background: #000;
                /* The SVG dimensions are authoritative (set via attributes/JS). Avoid
                    CSS-based max-width/max-height which would scale the canvas to the
                    user's viewport and change the border size. */
            position: relative;
            z-index: 0;
        }

        /* Room List */
        .room-list {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid var(--lcars-blue);
            border-radius: 4px;
            padding: 10px;
        }

        .room-item {
            background: #1a1a1a;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 4px solid var(--lcars-orange);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .room-item:hover {
            background: #252525;
        }

        .room-item.selected {
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            border-left: 4px solid var(--lcars-orange);
            border-right: 2px solid var(--lcars-orange);
            box-shadow: 0 0 15px rgba(255, 156, 0, 0.5);
        }

        .room-item.dragging {
            background: linear-gradient(90deg, #2a2a2a, #3a3a3a);
            border: 3px solid var(--lcars-yellow);
            box-shadow: 0 0 20px rgba(255, 204, 102, 0.8);
            transform: scale(1.02);
        }

        .room-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .room-item-name {
            font-weight: bold;
            color: var(--lcars-orange);
        }

        .room-item-stats {
            font-size: 11px;
            color: #888;
        }

        .room-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #fff;
        }

        /* Deck Tabs */
        .deck-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .deck-tab {
            padding: 8px 15px;
            background: #222;
            border: 1px solid var(--lcars-blue);
            border-radius: 15px 15px 0 0;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .deck-tab.active {
            background: var(--lcars-blue);
            color: #000;
            font-weight: bold;
        }

        .deck-tab:hover:not(.active) {
            background: #333;
        }

        /* Status Bar */
        .status-bar {
            background: #111;
            padding: 10px 20px;
            border-top: 2px solid var(--lcars-blue);
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #888;
            position: relative;
            /* Reserve room on the right so floated controls never overlap status text */
            padding-right: 140px;
        }

        /* Left area (Deck / Rooms) stays left-aligned */
        .status-info {
            display: flex;
            gap: 20px;
            flex: 0 0 auto;
        }

        /* Title removed - no centered app title in status bar. */

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--lcars-blue);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--lcars-skyblue);
        }

        .value-display {
            display: inline-block;
            min-width: 40px;
            color: var(--lcars-yellow);
            font-weight: bold;
        }

        /* Modal Dialog */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: #1a1a1a;
            border: 3px solid var(--lcars-blue);
            border-radius: 10px;
            width: 500px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .modal-header {
            background: var(--lcars-blue);
            color: #000;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 7px 7px 0 0;
            cursor: move;
            user-select: none;
        }

        .modal-title {
            font-size: 20px;
            font-weight: bold;
        }

        .modal-close {
            background: var(--lcars-red);
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .modal-close:hover {
            background: #ff3333;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-field {
            margin-bottom: 15px;
        }

        .modal-field label {
            display: block;
            color: var(--lcars-skyblue);
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .modal-field input,
        .modal-field select {
            width: 100%;
            padding: 8px;
            background: #222;
            border: 1px solid var(--lcars-blue);
            color: #fff;
            font-size: 14px;
            border-radius: 4px;
        }

        .modal-field input[type="color"] {
            height: 50px;
            padding: 4px;
            cursor: pointer;
            border: 3px solid var(--lcars-blue);
        }
        
        .modal-field input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        .modal-field input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 2px solid #333;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Help Modal - No background fade */
        .help-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            pointer-events: none;
        }

        .help-modal .modal-dialog {
            pointer-events: all;
            width: 600px;
            max-width: 90vw;
        }

        .help-modal h3 {
            color: var(--lcars-orange);
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
            border-bottom: 2px solid var(--lcars-orange);
            padding-bottom: 5px;
        }

        .help-modal h3:first-child {
            margin-top: 0;
        }

        .help-modal p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .help-modal ul {
            color: #ccc;
            line-height: 1.8;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .help-modal li {
            margin-bottom: 8px;
        }

        .help-modal strong {
            color: var(--lcars-skyblue);
        }

        .help-modal em {
            color: var(--lcars-purple);
        }
        
        /* Canvas selection highlight */
        .canvas-highlight {
            pointer-events: none;
            fill: none;
            stroke: var(--lcars-orange);
            stroke-width: 3;
            stroke-dasharray: 5, 5;
            animation: dash 0.5s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }
        
        /* Mobile move mode buttons */
        .mobile-only {
            display: none;
        }
        
        /* Hidden by default; shown when Move Mode toggles the `active` class. */
        .mobile-move-buttons {
            display: none !important;
        }
        /* Stronger selector to override toolbar-row rules and ensure the
           move-mode controls do NOT render unless `.active` is set. */
        .toolbar-row-2.mobile-move-buttons {
            display: none !important;
        }
        /* On small screens, allow them to appear when active. Use !important to
           override the generic .toolbar-row-2 rule that sets display:flex. */
        @media (max-width: 768px) {
            .mobile-move-buttons.active,
            .toolbar-row-2.mobile-move-buttons.active {
                display: flex !important;
                gap: 6px;
                align-items: center;
            }
        }
        
        @media (max-width: 768px) {
            .mobile-only {
                display: inline-block;
            }
            
            .mobile-move-buttons.active {
                display: flex !important;
            }
            
            #moveModeToggle.active {
                background: var(--lcars-orange);
                color: #000;
            }
            /* Keep canvas-controls floating above the canvas on small screens as well
               (fixed to the bottom-right like the Help button). */
            .canvas-controls {
                position: fixed !important;
                right: 8px !important;
                bottom: 8px !important;
                display: inline-flex !important;
                gap: 6px !important;
                align-items: center !important;
                pointer-events: auto;
                z-index: 10004 !important;
            }
            /* Reduce top toolbar fonts and keep toolbar rows on a single line */
            .toolbar {
                flex-direction: row !important;
                gap: 6px !important;
                align-items: center;
            }
            .toolbar-row-1, .toolbar-row-2 {
                display: flex !important;
                flex-wrap: nowrap !important;
                gap: 6px !important;
                align-items: center !important;
            }
            /* Shrink button fonts by ~33% on small screens and reduce padding so they fit */
            .toolbar .help-tab-btn, .toolbar .btn, .canvas-control-btn, .toolbar button {
                font-size: 0.67rem !important;
                padding: 6px 8px !important;
                min-width: 36px !important;
                height: 34px !important;
            }
                /* Ensure the canvas container does not create page scrollbars on mobile
                    and keeps the SVG border as the true outer edge. Hide overflow so
                    panning is handled inside the canvas and the page itself remains static. */
                 .canvas-container {
                     height: calc(100vh - 84px - 56px); /* 84px for status bar, 56px for toolbar */
                     min-height: 220px;
                     max-height: none !important;
                     overflow: visible !important;
                     padding: 0 10px 84px 10px !important; /* bottom padding for status bar */
                     display: flex;
                     justify-content: center;
                     align-items: center;
                     touch-action: none !important;
                }
                /* Do not constrain the SVG with viewport-based max sizes. The SVG's
                    intrinsic size (attributes/JS) is authoritative for exports and
                    rendering; preventing CSS max-width/max-height avoids accidental
                    scaling that moves borders or changes pixel dimensions. */
                 #mdsCanvas {
                     width: auto !important;
                     height: auto !important;
                     max-width: none !important;
                     max-height: none !important;
                     touch-action: none !important;
                     position: relative;
                     z-index: 0;
                 }
                /* Ensure top toolbar is fixed and above the canvas on mobile */
                .toolbar {
                    position: fixed !important;
                    top: 6px !important;
                    right: 6px !important;
                    z-index: 12000 !important;
                    display: flex !important;
                    gap: 6px !important;
                }
                /* Keep the status bar fixed to the bottom so it's always visible */
                .status-bar {
                    position: fixed !important;
                    left: 0 !important;
                    right: 0 !important;
                    bottom: 0 !important;
                    z-index: 12000 !important;
                    padding-right: 140px !important;
                    padding-left: 20px !important;
                }
                /* Increase spacing between status fields so text doesn't touch controls */
                .status-info {
                    gap: 20px !important;
                    display: flex !important;
                    align-items: center !important;
                }
                /* Keep canvas-controls above the status bar and visible while panning */
                .canvas-controls {
                    position: fixed !important;
                    right: 8px !important;
                    bottom: 72px !important; /* sit above the fixed status bar */
                    z-index: 13000 !important;
                    pointer-events: auto !important;
                }
                /* Give the canvas container some bottom padding so content isn't hidden
                   behind the fixed status bar. */
                .canvas-container {
                    padding-bottom: 84px !important;
                }
        }
    </style>
</head>
<body>
    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle" onclick="toggleMobileMenu()">‚Ä∫</button>

    <!-- Modal Dialog -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">Edit Item</div>
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="modal-footer" id="modalFooter">
                <button class="btn btn-danger" id="modalDeleteBtn" onclick="modalDelete()">üóëÔ∏è Delete</button>
                <button class="btn" id="modalSaveBtn" onclick="modalSave()">üíæ Save</button>
            </div>
        </div>
    </div>

    <!-- Help Modal (no background fade) -->
    <div class="help-modal" id="helpModal" style="display:none;">
        <div class="modal-dialog">
            <div class="modal-header">
                <div class="modal-title">‚ùìMDS Generator Help</div>
                <button class="modal-close" onclick="closeHelp()">√ó</button>
            </div>
            <div class="modal-body" style="max-height:70vh; overflow-y:auto;">
                <h3>üññWelcome to MDS Generator!</h3>
                <p>This tool creates Multi-Deck Schematics (MDS) for Space Engineers ships with a LCARS-inspired visual style.</p>
                
                <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
                <ul>
                    <li><strong>P</strong>: Toggle Pan / Move mode (click-drag to pan when on)</li>
                    <li><strong>+</strong> or <strong>=</strong>: Zoom In</li>
                    <li><strong>-</strong>: Zoom Out</li>
                    <li><strong>0</strong>: Reset zoom to 100%</li>
                    <li><strong>Space (legacy)</strong>: (previously temporary-pan) removed ‚Äî use Middle Mouse Button to temporary-pan</li>
                </ul>

                <h3>üñ±Ô∏è Mouse & Touch Controls</h3>
                <ul>
                    <li><strong>Left Click + Drag</strong>: Select and drag rooms/outlines (desktop). When <em>Pan Mode</em> is ON, left-drag will pan the canvas instead.</li>
                    <li><strong>Middle Mouse Button (MMB) Hold + Drag</strong>: Temporary pan while held ‚Äî the Pan button will appear active while MMB is down and the debug flag will show <em>panMode: on</em>.</li>
                    <li><strong>Mouse Wheel</strong>: Scroll as usual; <strong>Ctrl+Wheel</strong> or <strong>Shift+Wheel (while hovering canvas)</strong> zooms around cursor position.</li>
                    <li><strong>Touch</strong>: Pinch to zoom; two-finger pan; long-press and drag for mobile move mode (if enabled).</li>
                </ul>
                
                <h3>üöÄShip Configuration</h3>
                <ul>
                    <li><strong>Ship Name:</strong> Enter your ship's name (displays at the top of the MDS)</li>
                    <li><strong>Color Palette:</strong> Choose from the Primary, Warrior (Red), Matrix (Green), Imperial (Dark Green), Traders (Gold), or Custom themes</li>
                    <li><strong>Show Grid:</strong> Toggle grid lines on/off for alignment reference</li>
                    <li><strong>Show Arches:</strong> Display decorative LCARS-inspired arch elements</li>
                    <li><strong>Auto Outline:</strong> Automatically draw hull outlines around occupied deck spaces</li>
                    <li><strong>Grid Cell Size:</strong> Adjust the size of each grid cell (affects overall scale)</li>
                </ul>
                
                <h4><u>‚öôÔ∏è Advanced Settings</u></h4>
                <ul>
                    <li><strong>Banner Font Size:</strong> Set title/subtitle font size (8-200px) - use number input for precise control</li>
                    <li><strong>Banner Font Offset X/Y:</strong> Fine-tune title positioning with pixel offsets</li>
                    <li><strong>Outline Padding:</strong> Control spacing between rooms and hull outline</li>
                    <li><strong>Outline Style:</strong> Choose rounded or sharp corners for the hull outline</li>
                    <li><strong>Ship Outline Color:</strong> Set the color of the auto-generated hull outline</li>
                    <li><strong>Font Color:</strong> Default text color for ship configuration (separate from room fonts)</li>
                    <li><strong>Text Shadow:</strong> Add shadow effect to text for better readability</li>
                    <li><strong>Show Deck Name:</strong> Toggle deck labels in the output</li>
                </ul>
                
                <h3>üèóÔ∏è Deck Editor</h3>
                <ul>
                    <li><strong>Deck Name:</strong> Name each deck level (e.g., "Bridge", "Engineering", "Cargo Bay")</li>
                    <li><strong>Grid Width/Height:</strong> Set the dimensions of each deck's grid</li>
                    <li><strong>+ Add Deck:</strong> Create additional deck levels for multi-story ships</li>
                    <li><strong>Deck Tabs:</strong> Click tabs to switch between decks for editing</li>
                    <li><strong>Delete Deck:</strong> Remove unwanted deck levels</li>
                </ul>
                
                <h3>üè† Rooms</h3>
                <ul>
                    <li><strong>+ Add Room:</strong> Create new rooms (opens modal with customization options)</li>
                    <li><strong>Room Name:</strong> Label the room (e.g., "Bridge", "Medbay", "Reactor")</li>
                    <li><strong>Width/Height:</strong> Set room dimensions in grid cells (1-30)</li>
                    <li><strong>Background Color:</strong> Choose room color from palette picker</li>
                    <li><strong>Font Color:</strong> Set text color independently from background</li>
                    <li><strong>Font Size:</strong> Customize text size per room (8-32px)</li>
                    <li><strong>Font Offset X/Y:</strong> Fine-tune text positioning within the room</li>
                    <li><strong>Rotation:</strong> Rotate rooms 0-360¬∞ using the slider (updates live!)</li>
                    <li><strong>Drag & Drop:</strong> Drag rooms from the list onto the canvas grid</li>
                    <li><strong>Double-Click:</strong> Edit room properties</li>
                    <li><strong>Single-Click:</strong> Select/highlight a room</li>
                </ul>
                
                <h3>‚úèÔ∏è Outline Shapes</h3>
                <ul>
                    <li><strong>+ Add Outline Shape:</strong> Create decorative shapes (opens modal)</li>
                    <li><strong>Shape Type:</strong> Choose Rectangle, Ellipse, or Triangle</li>
                    <li><strong>Width/Height:</strong> Set shape dimensions in grid cells</li>
                    <li><strong>Color:</strong> Choose shape fill color</li>
                    <li><strong>Z-Index:</strong> Control layering (0=back, 100=front) - shapes draw behind rooms</li>
                    <li><strong>Rotation:</strong> Rotate shapes 0-360¬∞ using the slider (updates live!)</li>
                    <li><strong>Show Border:</strong> Toggle shape border on/off (auto-hides when overlapping rooms)</li>
                    <li><strong>Triangles:</strong> Point upward by default - use rotation to change orientation</li>
                    <li><strong>Use Cases:</strong> Hull sections, nacelles, wings, decorative elements</li>
                </ul>
                
                <h3>üíæ Import/Export</h3>
                <ul>
                    <li><strong>Export JSON:</strong> Save entire ship design as a JSON file for backup or sharing</li>
                    <li><strong>Import JSON:</strong> Load a previously saved ship design (replaces current design)</li>
                    <li><strong>Export PNG:</strong> Generate a high-quality image of your MDS for documentation or display</li>
                    <li><strong>SE LCD Text:</strong> Convert your MDS to Space Engineers LCD-compatible text for in-game display</li>
                    <li><strong>Auto-Save:</strong> All changes are automatically saved to browser localStorage</li>
                </ul>
                <h3>üé® Custom Palette Editor</h3>
                
                <ul>
                    <li><strong>Edit Colors:</strong> Customize every color in the palette (accent1, accent2, hull, border, etc.)</li>
                    <li><strong>Export Palette:</strong> Save your custom palette as a JSON file</li>
                    <li><strong>Import Palette:</strong> Load a previously saved palette</li>
                    <li><strong>Persistence:</strong> Custom palettes are saved automatically and persist across sessions</li>
                </ul>

                <h3>üí∞ Tips & üß† Thoughts</h3>
                <ul>
                    <li><strong>Live Preview:</strong> All rotation and font changes update instantly while editing</li>
                    <li><strong>Grid Snapping:</strong> Objects automatically align to grid cells when dragged</li>
                    <li><strong>Refresh Button:</strong> Click "Refresh" if something doesn't render correctly</li>
                    <li><strong>Layering:</strong> Outline shapes always draw behind rooms (Z-index controls shape layering only)</li>
                    <li><strong>Custom Workflows:</strong> Create outline shapes first for hull sections, then add rooms on top</li>
                    <li><strong>Rotation Tricks:</strong> Combine rotated triangles for nacelles, rotated rectangles for angled corridors</li>
                </ul>
                
            </div>
            <div class="modal-footer">
                <p><em>Created for Space Engineers enthusiasts. üññ</em></p>
                <br>
                <button class="btn" onclick="closeHelp()">Close</button>
            </div>
        </div>
    </div>

    <!-- SE LCD Modal -->
    <div class="help-modal" id="seLCDModal" style="display:none;">
        <div class="modal-dialog" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">üéÆ Space Engineers LCD Text</div>
                <button class="modal-close" onclick="closeSELCDModal()">√ó</button>
            </div>
            <div class="modal-body" style="max-height:70vh; overflow-y:auto;">
                <div class="control-group">
                    <label>Resolution:</label>
                    <select id="seLCDResolution" onchange="regenerateSELCDText()">
                        <option value="178">178x178 (Single LCD - 1x1 grid)</option>
                        <option value="512">512x512 (3x3 LCD grid - 9 panels)</option>
                        <option value="1024">1024x1024 (6x6 LCD grid - 36 panels)</option>
                        <option value="custom">Custom Grid (specify panels)</option>
                    </select>
                </div>
                
                <!-- Custom grid input (hidden by default) -->
                <div id="seLCDCustomGrid" style="display:none; margin-top: 10px;">
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <div style="flex: 1;">
                            <label>Panels Wide (X):</label>
                            <input type="number" id="seLCDCustomX" min="1" max="20" value="2" style="width: 100%; padding: 5px;" onchange="regenerateSELCDText()" />
                        </div>
                        <div style="flex: 1;">
                            <label>Panels Tall (Y):</label>
                            <input type="number" id="seLCDCustomY" min="1" max="20" value="2" style="width: 100%; padding: 5px;" onchange="regenerateSELCDText()" />
                        </div>
                    </div>
                </div>
                
                <div id="seLCDGridInfo" style="margin-top: 10px; color: var(--lcars-yellow);"></div>
                <br>
                
                <p><strong>Instructions:</strong></p>
                <ol>
                    <li>Select desired resolution above</li>
                    <li id="seLCDInstructionTile">For multi-panel grids: Click each tile tab and copy text to corresponding LCD panel</li>
                    <li>Click "Copy to Clipboard" below</li>
                    <li>In Space Engineers, access an LCD panel (or multiple panels in a grid)</li>
                    <li>Set Content to "Text and Images"</li>
                    <li>Set Font to <strong>MONOSPACE</strong></li>
                    <li>Set Font Size to <strong>0.1</strong> (minimum)</li>
                    <li>Set Text Padding to <strong>0</strong></li>
                    <li>Paste the text (Ctrl+V)</li>
                </ol>
                <br>
                
                <!-- Tile selector tabs (hidden for 178x178) -->
                <div id="seLCDTileSelector" style="display:none; margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;"><strong>Select LCD Panel Tile:</strong></label>
                    <div id="seLCDTileTabs" style="display: flex; flex-wrap: wrap; gap: 5px;"></div>
                </div>
                
                <div class="control-group">
                    <label id="seLCDPreviewLabel">LCD Text Preview:</label>
                    <textarea id="seLCDTextArea" readonly style="width: 100%; height: 200px; font-family: monospace; font-size: 6px; background: #222; color: #0f0; border: 1px solid var(--lcars-blue); padding: 10px; resize: vertical;"></textarea>
                </div>
                <br>
                <p id="seLCDStringLength" style="color: var(--lcars-yellow);"><em>String Length: 0 characters</em></p>
                <br>
                <p style="color: var(--lcars-tan); font-size: 12px;">
                    <em>Conversion algorithm based on <a href="https://github.com/Whiplash141/Whips-Image-Converter" target="_blank" style="color: var(--lcars-blue);">Whip's Image Converter</a> by <a href="https://github.com/Whiplash141" target="_blank" style="color: var(--lcars-blue);">Whiplash141</a></em>
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="copySELCDText()">üìã Copy to Clipboard</button>
                <button class="btn btn-secondary" onclick="closeSELCDModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Sidebar Controls -->
    <div class="sidebar">
        <h1>üññ MDS Generator</h1>
        
        <h2 class="primary">Ship Configuration</h2>
        <div class="control-group">
            <label>Ship Name</label>
            <input type="text" id="shipName" value="SS Endeavor" />
        </div>

        <h2 class="accordion secondary collapsed" onclick="toggleAccordion(this)">Advanced Settings</h2>
        <div class="accordion-content collapsed" id="advancedSettingsContent">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showGrid" checked />
                    Show Grid Lines
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showArches" checked />
                    Show LCARS Arches
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showDeckName" checked />
                    Show Deck Name
                </label>
            </div>

            <div class="control-group">
                <label>Font Color</label>
                <input type="color" id="fontColor" value="#000000" />
            </div>

            <div class="control-group">
                <label>Banner Font Size (px)</label>
                <input type="number" id="bannerFontSize" min="8" max="200" value="24" />
            </div>

            <div class="control-group">
                <label>Banner Scale (multiplier)</label>
                <input type="number" id="bannerScale" min="0.1" max="10" step="0.1" value="1.0" />
            </div>

            <!-- Arches scaling removed per user request; arches will no longer scale independently -->

            <div class="control-group">
                <label>Banner Font Offset X (px)</label>
                <input type="number" id="bannerFontOffsetX" value="0" min="-100" max="100" />
            </div>

            <div class="control-group">
                <label>Banner Font Offset Y (px)</label>
                <input type="number" id="bannerFontOffsetY" value="0" min="-100" max="100" />
            </div>
        </div>

        <h2 class="accordion secondary collapsed" onclick="toggleAccordion(this)">Manual Outline Mode</h2>
        <div class="accordion-content collapsed" id="manualOutlineControls">
            <div class="control-group">
                <button class="btn btn-secondary" onclick="addManualOutline()">+ Add Outline Shape</button>
            </div>
            <div class="control-group">
                <label>Outline Shapes</label>
                <div class="room-list" id="outlineShapeList"></div>
            </div>
        </div>

        <h2 class="primary">Deck Editor</h2>
        <div class="deck-tabs" id="deckTabs"></div>
        <div class="control-group">
            <button class="btn" onclick="addDeck()">+ Add Deck</button>
            <button class="btn btn-danger" onclick="removeDeck()">- Remove Deck</button>
        </div>

        <div class="control-group">
            <label>Deck Name</label>
            <input type="text" id="deckName" value="Main Deck" />
        </div>

        <h2 class="accordion secondary collapsed" onclick="toggleAccordion(this)">Display Settings</h2>
        <div class="accordion-content collapsed" id="displaySettingsContent">
        <div class="control-group">
            <label>Grid Width</label>
            <input type="number" id="gridWidth" value="10" min="5" max="30" />
        </div>

        <div class="control-group">
            <label>Grid Height</label>
            <input type="number" id="gridHeight" value="8" min="5" max="30" />
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="autoOutline" checked />
                Auto Hull Outline
            </label>
        </div>

        <div class="control-group">
            <label>Cell Size (px): <span class="value-display" id="cellSizeValue">60</span></label>
            <input type="range" id="cellSize" min="30" max="100" value="60" />
        </div>

        <div class="control-group">
            <label>Hull Outline Thickness: <span class="value-display" id="outlinePaddingValue">0.5</span></label>
            <input type="range" id="outlinePadding" min="0.1" max="1.0" step="0.1" value="0.5" />
        </div>

        <div class="control-group">
            <label>Outline Style</label>
            <select id="outlineStyle">
                <option value="rounded">Rounded</option>
                <option value="sharp">Sharp</option>
            </select>
        </div>

        <div class="control-group">
            <label>Hull Outline Color</label>
            <input type="color" id="shipOutlineColor" value="#767676" />
        </div>
        </div>

        <h2 class="secondary">Rooms</h2>
        <div class="control-group">
            <button class="btn" onclick="addRoom()">+ Add Room</button>
        </div>

        <div class="room-list" id="roomList"></div>

        <h2 class="primary">Ship Images</h2>
        <div class="control-group">
            <button class="btn" onclick="exportSVG()">üìÑ Download SVG</button>
            <button class="btn" onclick="exportPNG()">üñºÔ∏è Download PNG</button>
            <button class="btn" onclick="exportSELCD()">üéÆ SE LCD Text</button>
        </div>

        <h2 class="primary">Ship Data</h2>
        <div class="control-group">
            <button class="btn" onclick="exportShip()">üíæ Export Ship (.json)</button>
            <button class="btn btn-secondary" onclick="importShip()">üìÇ Import Ship (.json)</button>
            <input type="file" id="shipFileInput" accept=".json" style="display:none" />
        </div>

        <h2 class="accordion primary collapsed" onclick="toggleAccordion(this)">Settings</h2>
        <div class="accordion-content collapsed" id="settingsContent">
            <div class="control-group">
                <label>Color Palette</label>
                <select id="colorPalette">
                    <option value="lcars">Classic (Standard Alliance)</option>
                    <option value="warriors">Crimson (Warrior Clans)</option>
                    <option value="collective">Matrix (The Collective)</option>
                    <option value="imperial">Imperial (Star Empire)</option>
                    <option value="traders">Golden (Trade Consortium)</option>
                    <option value="custom">Custom Palette</option>
                </select>
            </div>
            
            <div class="control-group" id="customPaletteControls" style="display:none;">
                <button class="btn btn-secondary" onclick="editCustomPalette()">üé® Edit Custom Palette</button>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="textShadow" />
                    Text Drop Shadow
                </label>
            </div>
            
            <div class="control-group">
                <button class="btn btn-secondary" onclick="exportSettings()">‚öôÔ∏è Export Settings</button>
                <button class="btn btn-secondary" onclick="importSettings()">‚öôÔ∏è Import Settings</button>
                <input type="file" id="settingsFileInput" accept=".json" style="display:none" />
            </div>
            
            <hr class="secondary" />
            <h3 style="color: var(--lcars-red); margin-top: 20px; margin-bottom: 10px; font-size: 16px;">‚ö†Ô∏è DANGER ZONE</h3>
            <div class="control-group">
                <button class="btn btn-danger" onclick="clearAllRooms()">üóëÔ∏è Clear All Rooms</button>
                <p style="color: #888; font-size: 11px; margin-top: 10px;">Removes all rooms from the current deck. This cannot be undone!</p>
            </div>
            <div class="control-group">
                <button class="btn btn-danger" onclick="clearLocalStorage()">üí• SELF DESTRUCT</button>
                <p style="color: #888; font-size: 11px; margin-top: 10px;">Clears all saved ship data and settings from browser storage. This cannot be undone!</p>
            </div>
        </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="canvas-area">
        <div class="toolbar">
            <div class="toolbar-row-1">
                <!-- Mobile-only Move Mode toggle (appears on small screens) -->
                <button class="btn btn-secondary mobile-only" id="moveModeToggle" onclick="toggleMobileMoveMode()">üîí Move Mode</button>
                <!-- Help button: compact '?' icon expands to '?Help' on hover - styled like deck tabs -->
                <button id="helpBtn" class="help-tab-btn" onclick="showHelp()" title="MDS Generator Help">
                    <span class="help-icon">&nbsp;&nbsp;‚ùì</span><span class="help-label">Help</span>
                </button>
            </div>
                <!-- Mobile move-mode controls: cycle/select when Move Mode is active -->
            <div class="toolbar-row-2 mobile-move-buttons" id="mobileMoveButtons">
                <button class="btn btn-secondary" id="mobileToggleMode" onclick="toggleMobileMode()">üì¶ Rooms</button>
                <button class="btn btn-secondary" onclick="cycleMobilePrev()">‚óÄ</button>
                <button class="btn btn-secondary" onclick="cycleMobileNext()">‚ñ∂</button>
            </div>
        </div>

        <div class="canvas-container">
            <svg id="mdsCanvas" width="800" height="600"></svg>
            <!-- Touch-hold overlay: appears under the finger during long-press -->
            <!-- Enlarged touch-hold overlay (about 4x bigger) so finger doesn't occlude it -->
            <!-- Touch-hold overlay removed per user preference. Progress for
                 three-finger hold is shown by filling the Move Mode button. -->
        </div>
        <div class="status-bar">
            <div class="status-info">
                <span id="statusDeck">Deck: 1</span>
                <span id="statusRooms">Rooms: 0</span>
                <span id="viewDebugZoom" style="margin-left: 16px; color: var(--lcars-yellow); display:none;">zoom: 1</span>
                <span id="viewDebugPan" style="margin-left: 10px; color: var(--lcars-yellow); display:none;">pan: 0, 0</span>
                <span id="viewDebugFlags" style="margin-left: 10px; color: var(--lcars-yellow); display:none;">panMode: off</span>
            </div>
                <!-- App title removed per user request -->
                <div class="canvas-controls" id="canvasControls" role="toolbar" aria-label="Canvas Controls">
                <button class="canvas-control-btn" id="zoomOutBtn" title="Zoom Out">‚àí</button>
                <button class="canvas-control-btn" id="zoomInBtn" title="Zoom In">+</button>
                <button class="canvas-control-btn" id="panToggleBtn" title="Pan/Move">‚úã</button>
            </div>
        </div>
    </div>

    <script>
        // LCARS Color Palette - Define FIRST before using
        const LCARS_COLORS = {
            ORANGE: "#FF9C00",
            PINK: "#CC6699",
            BLUE: "#9999FF",
            PURPLE: "#CC99CC",
            RED: "#CC6666",
            YELLOW: "#FFCC66",
            TAN: "#FFCC99",
            SKY_BLUE: "#6699CC",
            PEACH: "#FF9966",
            BACKGROUND: "#000000",
            TEXT: "#FFFFFF",
            BORDER: "#9999FF",
            GRID: "#333333"
        };

        const COLOR_PALETTES = {
            lcars: {
                name: "Classic (Standard Alliance)",
                background: "#000000",
                text: "#FFFFFF",
                border: "#9999FF",
                grid: "#333333",
                hull: "#000000",
                accent1: "#FF9C00",
                accent2: "#6699CC",
                colors: {
                    ORANGE: "#FF9C00",
                    PINK: "#CC6699",
                    BLUE: "#9999FF",
                    PURPLE: "#CC99CC",
                    RED: "#CC6666",
                    YELLOW: "#FFCC66",
                    TAN: "#FFCC99",
                    SKY_BLUE: "#6699CC",
                    PEACH: "#FF9966"
                }
            },
            warriors: {
                name: "Crimson (Warrior Clans)",
                background: "#0a0000",
                text: "#FFFFFF",
                border: "#8B0000",
                grid: "#330000",
                hull: "#0a0000",
                accent1: "#8B0000",
                accent2: "#FFD700",
                colors: {
                    DARK_RED: "#8B0000",
                    BLOOD_RED: "#CC0000",
                    GOLD: "#FFD700",
                    DARK_GOLD: "#B8860B",
                    STEEL: "#708090",
                    BRONZE: "#CD7F32",
                    CRIMSON: "#DC143C",
                    RUST: "#B7410E",
                    AMBER: "#FFBF00"
                }
            },
            collective: {
                name: "Matrix (The Collective)",
                background: "#000a00",
                text: "#00FF00",
                border: "#00AA00",
                grid: "#003300",
                hull: "#000a00",
                accent1: "#00FF00",
                accent2: "#00AA00",
                colors: {
                    BRIGHT_GREEN: "#00FF00",
                    LIME: "#00CC00",
                    FOREST: "#00AA00",
                    DARK_GREEN: "#008800",
                    TEAL: "#008080",
                    CYAN: "#00FFFF",
                    STEEL: "#708090",
                    OLIVE: "#556B2F",
                    MINT: "#98FF98"
                }
            },
            imperial: {
                name: "Imperial (Star Empire)",
                background: "#000a00",
                text: "#FFFFFF",
                border: "#228B22",
                grid: "#1a3a1a",
                hull: "#000a00",
                accent1: "#228B22",
                accent2: "#FFD700",
                colors: {
                    FOREST_GREEN: "#228B22",
                    IMPERIAL_GREEN: "#2E8B57",
                    GOLD: "#FFD700",
                    SILVER: "#C0C0C0",
                    JADE: "#00A86B",
                    EMERALD: "#50C878",
                    DARK_GREEN: "#006400",
                    BRONZE: "#CD7F32",
                    SAGE: "#87AE73"
                }
            },
            traders: {
                name: "Golden (Trade Consortium)",
                background: "#1a0a00",
                text: "#FFFFFF",
                border: "#FFD700",
                grid: "#3a2a1a",
                hull: "#1a0a00",
                accent1: "#FFD700",
                accent2: "#FF8C00",
                colors: {
                    GOLD: "#FFD700",
                    ORANGE: "#FF8C00",
                    BRONZE: "#CD7F32",
                    COPPER: "#B87333",
                    AMBER: "#FFBF00",
                    BROWN: "#8B4513",
                    TAN: "#D2B48C",
                    RUST: "#B7410E",
                    YELLOW: "#FFD700"
                }
            },
            custom: {
                name: "Custom Palette",
                background: "#000000",
                text: "#FFFFFF",
                border: "#9999FF",
                grid: "#333333",
                hull: "#000000",
                accent1: "#FF9C00",
                accent2: "#6699CC",
                colors: {
                    COLOR_1: "#FF9C00",
                    COLOR_2: "#CC6699",
                    COLOR_3: "#9999FF",
                    COLOR_4: "#CC99CC",
                    COLOR_5: "#CC6666",
                    COLOR_6: "#FFCC66",
                    COLOR_7: "#FFCC99",
                    COLOR_8: "#6699CC",
                    COLOR_9: "#FF9966"
                }
            }
        };

        const ROOM_TYPE_COLORS = {
            cargo: 0,        // First accent color
            helm: 1,         // Second accent
            bridge: 1,
            medical: 2,      // Third color
            medbay: 2,
            armory: 3,       // Fourth color
            weapons: 3,
            engineering: 4,  // Fifth color
            reactor: 4,
            power: 4,
            quarters: 5,     // Sixth color
            sleeping: 5,
            rec: 6,          // Seventh color
            recreation: 6,
            lab: 7,          // Eighth color
            laboratory: 7,
            storage: 8,      // Ninth color
            hangar: 0
        };

        // Global State - NOW safe to reference COLOR_PALETTES
        let config = {
            name: "SE Endeavor",
            manual_outlines: [], // Global outlines array - not tied to any specific deck
            decks: [
                {
                    number: 1,
                    name: "Main Deck",
                    grid_width: 10,
                    grid_height: 8,
                    rooms: []
                }
            ],
            grid_cell_size: 60,
            padding: 40,
            font_size: 14,
            text_color: "#000000",
            text_shadow: false,
            show_deck_name: true,
            ship_outline_color: "#767676",
            show_arches: true,
            show_grid: true,
            outline_style: "rounded",
            auto_outline: true,
            outline_padding: 0.5,
            color_palette: "lcars",
            manual_outline_mode: false,
            // Scale multipliers to allow larger canvases while keeping banner/arches legible
            banner_scale: 1.0,
            // arches_scale removed; arches no longer scale independently
        };

        let currentDeckIndex = 0;
        let selectedRoomIndex = -1;
        let selectedOutlineIndex = -1;
        let draggedRoomIndex = -1;
        let draggedOutlineIndex = -1;
        let dragOffset = { x: 0, y: 0 };
        let isDragging = false;
        let currentPalette = COLOR_PALETTES.lcars;
        
        // Mobile move mode state
        let isMobileMoveMode = false;
        let mobileSelectionMode = 'rooms'; // 'rooms' or 'outlines'

        // View transform (zoom and pan) settings - imported from three-buttons
        let view = { zoom: 1.0, panX: 0, panY: 0 };
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 4.0;
        let panMode = false; // When true, click-drag pans the canvas
        let isPanning = false;
        let panStart = { x: 0, y: 0, startPanX: 0, startPanY: 0 };
        const VIEW_MARGIN_RATIO = 0.15; // 15% top and bottom margins
        let skipClampNextUpdate = false;
        let isPinching = false;
        let pinchStartDistance = 0;
        let pinchStartZoom = 1;
        let pinchStartCentroid = null;
        let twoFingerPanStart = null;
        // Touch-hold animation state
        let touchHoldRaf = null;
        let touchHoldActive = false;
        let touchHoldStartX = 0;
        let touchHoldStartY = 0;
        let touchHoldDuration = 600; // ms
        let touchHoldStartTime = 0;
        let touchHoldOnComplete = null;
        // Single-touch tap tracking (for Move Mode tap-to-place)
        let touchTapStartTime = 0;
        let touchTapStartX = 0;
        let touchTapStartY = 0;
        let touchTapMoved = false;
        // Active transient single-touch move handler so we can remove it on release
        let activeSingleTouchMoveHandler = null;
        // Long-press timer id (no overlay visual)
        let longPressTimerId = null;
        // Two-/multi-finger hold timers
        let twoFingerTimerId = null;
        let multiFingerTimerId = null;
        let twoFingerHoldActive = false;
        let multiFingerHoldActive = false;
        // Track whether mouse is hovering the canvas for wheel-hover zoom
        let isHoveringCanvas = false;
        // Track if user has manually panned/changed view; this prevents auto-centering on unrelated clicks
        let userHasPannedView = false;
        // When pan mode is disabled, allow preserving the last pan position without clamping
        let preservePanAfterDisable = false;

        function clampPan(panX, panY, noClamp = false) {
            try {
                const svg = document.getElementById('mdsCanvas');
                const container = document.querySelector('.canvas-container');
                const svgWidth = parseFloat(svg.getAttribute('width')) || svg.clientWidth;
                const svgHeight = parseFloat(svg.getAttribute('height')) || svg.clientHeight;
                const scaledWidth = svgWidth * view.zoom;
                const scaledHeight = svgHeight * view.zoom;
                const availableWidth = container.clientWidth;
                const availableHeight = container.clientHeight;

                // If caller requested us to not clamp (force allow) OR preserving pan after disabling, bypass clamping
                if (noClamp || preservePanAfterDisable) {
                    return { x: panX, y: panY };
                }

                // If the scaled content is smaller than the container, center it horizontally/vertically
                let minX = Math.min(0, availableWidth - scaledWidth);
                let maxX = Math.max(0, availableWidth - scaledWidth);
                let minY = Math.min(0, availableHeight - scaledHeight);
                let maxY = Math.max(0, availableHeight - scaledHeight);

                // The above yields min=0, max=0 when the scaled size fits; but we center instead of clamping
                let clampedX = panX;
                let clampedY = panY;

                if (scaledWidth <= availableWidth) {
                    clampedX = Math.round((availableWidth - scaledWidth) / 2);
                } else {
                    clampedX = Math.max(Math.min(panX, 0), availableWidth - scaledWidth);
                }
                if (scaledHeight <= availableHeight) {
                    clampedY = Math.round((availableHeight - scaledHeight) / 2);
                } else {
                    clampedY = Math.max(Math.min(panY, 0), availableHeight - scaledHeight);
                }
                return { x: clampedX, y: clampedY };
            } catch (err) {
                return { x: panX, y: panY };
            }
        }

        function updateTransform() {
            const svg = document.getElementById('mdsCanvas');
            if (!svg) return;
            svg.style.transformOrigin = '0 0';
            let clamped;
            if (skipClampNextUpdate) {
                clamped = { x: view.panX, y: view.panY };
                skipClampNextUpdate = false;
            } else {
                // When actively panning (isPanning) or persistent panMode is on,
                // bypass clamping so temporary or persistent pans aren't snapped.
                clamped = clampPan(view.panX, view.panY, panMode || isPanning);
            }
            view.panX = clamped.x;
            view.panY = clamped.y;
            svg.style.transform = `translate(${view.panX}px, ${view.panY}px) scale(${view.zoom})`;
            updateViewDebug();
        }

        function saveViewToConfig() {
            config.view = config.view || {};
            config.view.zoom = view.zoom;
            config.view.panX = view.panX;
            config.view.panY = view.panY;
            saveToLocalStorage();
            updateViewDebug();
        }

        function updateViewDebug() {
            const z = document.getElementById('viewDebugZoom');
            const p = document.getElementById('viewDebugPan');
            const f = document.getElementById('viewDebugFlags');
            // Keep debug elements hidden in production per user preference.
            if (!z || !p || !f) return;
            z.textContent = `zoom: ${view.zoom.toFixed(2)}`;
            p.textContent = `pan: ${Math.round(view.panX)}, ${Math.round(view.panY)}`;
            // Do not display or update the flags text to the status bar.
            f.textContent = '';
            f.style.display = 'none';
            z.style.display = 'none';
            p.style.display = 'none';
        }

        function setZoom(newZoom, anchorX = null, anchorY = null, noClamp = false) {
            const oldZoom = view.zoom;
            // Refresh debug values (kept hidden per user preference)
            updateViewDebug();
            newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
            if (newZoom === oldZoom) return;
            const container = document.querySelector('.canvas-container');
            if (anchorX === null || anchorY === null) {
                const rect = container.getBoundingClientRect();
                anchorX = rect.width / 2;
                anchorY = rect.height / 2;
            }
            const newPanX = anchorX - (anchorX - view.panX) * (newZoom / oldZoom);
            const newPanY = anchorY - (anchorY - view.panY) * (newZoom / oldZoom);
            view.zoom = newZoom;
            // user actively changed view via zoom; treat as user interaction
            userHasPannedView = true;
            // A zoom is a deliberate user interaction; stop preserving an old pan after toggle
            preservePanAfterDisable = false;
            // If the caller doesn't want clamping (e.g., zoom buttons), skip clamp on next update
            if (noClamp) skipClampNextUpdate = true;
            const clamped = clampPan(newPanX, newPanY, noClamp || panMode);
            view.panX = clamped.x;
            view.panY = clamped.y;
            saveViewToConfig();
            updateTransform();
            render();
        }

        function zoomIn() { setZoom(view.zoom * 1.15, null, null, true); }
        function zoomOut() { setZoom(view.zoom / 1.15, null, null, true); }

        function togglePanMode(on = null) {
            // Toggle or set explicitly
            const btn = document.getElementById('panToggleBtn');
            if (typeof on === 'boolean') panMode = on; else panMode = !panMode;
            // When turning on pan mode, disable mobile move mode to avoid conflicts
            if (panMode && isMobileMoveMode) {
                // Turn off mobile move mode so pan takes precedence on desktop/hover
                toggleMobileMoveMode();
            }
            if (panMode) preservePanAfterDisable = false;
            if (btn) btn.classList.toggle('active', panMode);
            /* TODO - consider for removal: desktop move button state sync
            const moveBtn = document.getElementById('moveModeBtn');
            if (moveBtn) moveBtn.classList.toggle('active', !panMode);
            */
            // change cursor
            const svg = document.getElementById('mdsCanvas');
            svg.style.cursor = panMode ? 'grab' : 'default';
            // Clear any dragging states so the editor doesn't get stuck
            isDragging = false;
            draggedRoomIndex = -1;
            draggedOutlineIndex = -1;
            // Ensure if we are disabling pan mode we also stop any ongoing panning
            if (!panMode) {
                isPanning = false;
                // preserve the current pan position and avoid clamping on next update/lock
                preservePanAfterDisable = true;
            }
            // Save to config so view mode persists
            config.panMode = panMode;
            saveToLocalStorage();
            // When toggling off, preserve current pan but ensure no clamped snapping immediately
            skipClampNextUpdate = true;
            // If we're disabling pan and the view is not default center, mark it as user-panned
            if (!panMode) {
                try {
                    const container = document.querySelector('.canvas-container');
                    const deck = getCurrentDeck();
                    const cellSize = config.grid_cell_size;
                    const xBase = config.padding;
                    const yBase = 100;
                    const gridCenterX = xBase + (deck.grid_width * cellSize) / 2;
                    const gridCenterY = yBase + (deck.grid_height * cellSize) / 2;
                    const topMargin = Math.round(container.clientHeight * VIEW_MARGIN_RATIO);
                    const availableHeight = container.clientHeight - (topMargin * 2);
                    const centerPanX = Math.round(container.clientWidth / 2 - gridCenterX * view.zoom);
                    const centerPanY = Math.round(topMargin + (availableHeight / 2) - gridCenterY * view.zoom);
                    // If the view differences exceed a small epsilon, consider the user panned
                    if (Math.abs(view.panX - centerPanX) > 2 || Math.abs(view.panY - centerPanY) > 2) {
                        userHasPannedView = true;
                    }
                } catch (err) {
                    // ignore errors computing center
                }
            }
            updateTransform();
            updateViewDebug();
        }

        // Initialize
        function init() {
            // Load from localStorage first
            loadFromLocalStorage();
            // Ensure pan and mobile move are disabled on fresh load/refresh
            panMode = false;
            isMobileMoveMode = false;
            if (config) config.panMode = false;
            
            setupEventListeners();
            syncUIFromConfig();
            renderDeckTabs();
            renderRoomList();
            renderOutlineList();
            
            // Restore view (zoom/pan) if available, or use defaults
            if (config.view) {
                view.zoom = config.view.zoom || view.zoom;
                view.panX = config.view.panX || view.panX;
                view.panY = config.view.panY || view.panY;
                saveViewToConfig();
                // Update transform after render
                setTimeout(() => { updateTransform(); render(); updateViewDebug(); }, 50);
            } else {
                setTimeout(() => { render(); }, 50);
            }
            // Reflect pan/move UI state (start disabled by default)
            const panBtn = document.getElementById('panToggleBtn');
            if (panBtn) panBtn.classList.toggle('active', false);
            const moveToggleBtn = document.getElementById('moveModeToggle');
            if (moveToggleBtn) {
                moveToggleBtn.classList.remove('active');
                moveToggleBtn.textContent = 'üîí Move Mode';
            }
            const mobileButtons = document.getElementById('mobileMoveButtons');
            if (mobileButtons) mobileButtons.classList.remove('active');
            const svg = document.getElementById('mdsCanvas');
            if (svg) {
                svg.style.cursor = 'default';
                svg.style.touchAction = 'auto';
            }
        }

        // LocalStorage functions
        function saveToLocalStorage() {
            try {
                // Include custom palette in config
                config.custom_palette = COLOR_PALETTES.custom;
                localStorage.setItem('mds_config', JSON.stringify(config));
            } catch (error) {
                console.error('Failed to save to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('mds_config');
                if (saved) {
                    const loadedConfig = JSON.parse(saved);
                    
                    // Merge loaded config with defaults to ensure all properties exist
                    config = { ...config, ...loadedConfig };
                    
                    // Restore custom palette if it exists
                    if (config.custom_palette) {
                        COLOR_PALETTES.custom = config.custom_palette;
                    }
                    
                    // Ensure color_palette is set
                    if (!config.color_palette) {
                        config.color_palette = 'lcars';
                    }
                    
                    currentPalette = COLOR_PALETTES[config.color_palette];
                    
                    // Show custom palette controls if custom is selected
                    if (config.color_palette === 'custom') {
                        const customControls = document.getElementById('customPaletteControls');
                        if (customControls) customControls.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Failed to load from localStorage:', error);
            }
        }

        function clearLocalStorage() {
            if (confirm('‚ö†Ô∏è WARNING: This will DELETE all saved ship data and settings!\n\nThis action cannot be undone. Are you absolutely sure?')) {
                localStorage.removeItem('mds_config');
                alert('üí• Local storage cleared! The page will now reload with default settings.');
                location.reload();
            }
        }

        function setupEventListeners() {
            // Ship settings
            document.getElementById('shipName').addEventListener('input', (e) => {
                config.name = e.target.value;
                saveToLocalStorage();
                render();
            });

            // Deck settings
            document.getElementById('deckName').addEventListener('input', (e) => {
                getCurrentDeck().name = e.target.value;
                renderDeckTabs();
                saveToLocalStorage();
                render();
            });

            document.getElementById('gridWidth').addEventListener('input', (e) => {
                getCurrentDeck().grid_width = parseInt(e.target.value);
                saveToLocalStorage();
                render();
            });

            document.getElementById('gridHeight').addEventListener('input', (e) => {
                getCurrentDeck().grid_height = parseInt(e.target.value);
                saveToLocalStorage();
                render();
            });

            // Display settings
            document.getElementById('showGrid').addEventListener('change', (e) => {
                config.show_grid = e.target.checked;
                saveToLocalStorage();
                render();
            });

            document.getElementById('showArches').addEventListener('change', (e) => {
                config.show_arches = e.target.checked;
                saveToLocalStorage();
                render();
            });

            document.getElementById('autoOutline').addEventListener('change', (e) => {
                config.auto_outline = e.target.checked;
                saveToLocalStorage();
                render();
            });

            document.getElementById('cellSize').addEventListener('input', (e) => {
                config.grid_cell_size = parseInt(e.target.value);
                document.getElementById('cellSizeValue').textContent = e.target.value;
                saveToLocalStorage();
                render();
            });

            document.getElementById('bannerFontSize').addEventListener('input', (e) => {
                config.banner_font_size = parseInt(e.target.value);
                saveToLocalStorage();
                render();
            });

            // Banner scale multiplier
            const bannerScaleInput = document.getElementById('bannerScale');
            if (bannerScaleInput) {
                bannerScaleInput.addEventListener('input', (e) => {
                    config.banner_scale = parseFloat(e.target.value) || 1.0;
                    saveToLocalStorage();
                    render();
                });
            }

            // Arches scaling UI removed - arches no longer scale independently

            document.getElementById('outlinePadding').addEventListener('input', (e) => {
                config.outline_padding = parseFloat(e.target.value);
                document.getElementById('outlinePaddingValue').textContent = e.target.value;
                saveToLocalStorage();
                render();
            });

            document.getElementById('outlineStyle').addEventListener('change', (e) => {
                config.outline_style = e.target.value;
                saveToLocalStorage();
                render();
            });

            document.getElementById('shipOutlineColor').addEventListener('input', (e) => {
                config.ship_outline_color = e.target.value;
                saveToLocalStorage();
                render();
            });

            document.getElementById('fontColor').addEventListener('input', (e) => {
                config.text_color = e.target.value;
                saveToLocalStorage();
                render();
            });

            document.getElementById('bannerFontOffsetX').addEventListener('input', (e) => {
                config.banner_font_offset_x = parseInt(e.target.value) || 0;
                saveToLocalStorage();
                render();
            });

            document.getElementById('bannerFontOffsetY').addEventListener('input', (e) => {
                config.banner_font_offset_y = parseInt(e.target.value) || 0;
                saveToLocalStorage();
                render();
            });

            document.getElementById('textShadow').addEventListener('change', (e) => {
                config.text_shadow = e.target.checked;
                saveToLocalStorage();
                render();
            });

            document.getElementById('showDeckName').addEventListener('change', (e) => {
                config.show_deck_name = e.target.checked;
                saveToLocalStorage();
                render();
            });

            // File inputs
            document.getElementById('shipFileInput').addEventListener('change', handleShipImport);
            document.getElementById('settingsFileInput').addEventListener('change', handleSettingsImport);
            
            // Color palette
            document.getElementById('colorPalette').addEventListener('change', (e) => {
                config.color_palette = e.target.value;
                currentPalette = COLOR_PALETTES[e.target.value];
                
                // Show/hide custom palette controls
                const customControls = document.getElementById('customPaletteControls');
                customControls.style.display = (e.target.value === 'custom') ? 'block' : 'none';
                
                applyColorPalette();
                saveToLocalStorage();
                render();
            });
            
            // Canvas drag and drop - Mouse / Touch events
            const svg = document.getElementById('mdsCanvas');
            // Route events to either the new/pan handlers or the legacy (old-index) handlers
            // Also handle Middle Mouse Button (MMB) here so temporary-pan works on first load.
            svg.addEventListener('touchstart', (e) => {
                // Cancel any previous timers (defensive)
                if (typeof twoFingerTimerId === 'number') { clearTimeout(twoFingerTimerId); twoFingerTimerId = null; } else { twoFingerTimerId = null; }
                if (typeof multiFingerTimerId === 'number') { clearTimeout(multiFingerTimerId); multiFingerTimerId = null; } else { multiFingerTimerId = null; }

                const touchCount = e.touches ? e.touches.length : 0;

                // Multi-finger (3+) => start toggle-move-mode timer (2s)
                if (touchCount >= 3) {
                    // record base positions to allow cancelling if user moves fingers
                    const startPositions = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY }));
                    const moveThreshold = 12; // px
                    // Start the visual progress on the Move Mode toggle instead of using a raw timer
                    const moveBtn = document.getElementById('moveModeToggle');
                    startMoveButtonProgress(moveBtn, 1000, 'var(--lcars-orange)', () => {
                        multiFingerHoldActive = true;
                        // toggle Move Mode (T flip-flop)
                        toggleMobileMoveMode();
                        // ensure two-finger panning won't auto-start while move-mode is on
                        if (typeof twoFingerTimerId === 'number') { clearTimeout(twoFingerTimerId); twoFingerTimerId = null; } else { twoFingerTimerId = null; }
                        multiFingerTimerId = null;
                    });
                    // Use a simple marker so cancel logic knows progress is active
                    multiFingerTimerId = true;

                    const cancelMultiIfMove = (ev) => {
                        // if any touch moved beyond threshold before timeout, cancel
                        for (let i = 0; i < ev.touches.length; i++) {
                            const cur = ev.touches[i];
                            const start = startPositions[i] || startPositions[0];
                            if (!start) continue;
                            if (Math.hypot(cur.clientX - start.x, cur.clientY - start.y) > moveThreshold) {
                                if (multiFingerTimerId) {
                                    // Cancel the button progress animation
                                    const moveBtn = document.getElementById('moveModeToggle');
                                    cancelMoveButtonProgress(moveBtn);
                                    multiFingerTimerId = null;
                                }
                                svg.removeEventListener('touchmove', cancelMultiIfMove);
                                svg.removeEventListener('touchend', cancelMultiIfMove);
                                svg.removeEventListener('touchcancel', cancelMultiIfMove);
                                break;
                            }
                        }
                    };
                    svg.addEventListener('touchmove', cancelMultiIfMove, { passive: false });
                    svg.addEventListener('touchend', cancelMultiIfMove, { passive: false });
                    svg.addEventListener('touchcancel', cancelMultiIfMove, { passive: false });

                    e.preventDefault();
                    return;
                }

                // Two-finger immediate temporary pan (MMB-like): when two fingers are
                // present we activate a separate temporary-pan state that lives only
                // while both fingers remain down. This is distinct from persistent
                // `panMode` and does not perform pinch-zoom.
                if (touchCount === 2 && !isMobileMoveMode) {
                    const t0 = e.touches[0];
                    const t1 = e.touches[1];
                    const cx = (t0.clientX + t1.clientX) / 2;
                    const cy = (t0.clientY + t1.clientY) / 2;

                    twoFingerHoldActive = true; // temporary two-finger pan state
                    // Initialize pan anchor so subsequent touchmove will pan (and not pinch)
                    pinchStartCentroid = { x: cx, y: cy };
                    twoFingerPanStart = { x: cx, y: cy, startPanX: view.panX, startPanY: view.panY };
                    // visually indicate temporary pan on the pan button without toggling persistent panMode
                    const panBtn = document.getElementById('panToggleBtn');
                    if (panBtn) {
                        panBtn.dataset._twoPrevActive = panBtn.classList.contains('active') ? '1' : '0';
                        panBtn.classList.add('active');
                    }

                    e.preventDefault();
                    return;
                }

                // Single-touch: show single-finger long-press indicator and route to legacy or pan handlers
                if (touchCount === 1) {
                    const t = e.touches[0];
                    // Track tap start for Move Mode tap-to-place
                    touchTapStartTime = performance.now();
                    touchTapStartX = t.clientX;
                    touchTapStartY = t.clientY;
                    touchTapMoved = false;

                    // Add a transient move listener to detect small movement (cancel tap)
                    const singleTouchMoveTracker = (mv) => {
                        if (!mv.touches || mv.touches.length === 0) return;
                        const m = mv.touches[0];
                        if (Math.hypot(m.clientX - touchTapStartX, m.clientY - touchTapStartY) > 8) {
                            touchTapMoved = true;
                            cancelAllTouchVisuals();
                        }
                    };
                    // Attach tracker and remember reference so it can be removed on touchend/touchcancel
                    activeSingleTouchMoveHandler = singleTouchMoveTracker;
                    svg.addEventListener('touchmove', activeSingleTouchMoveHandler, { passive: false });

                    // Start a long-press timer (no overlay). Dispatch 'longpress' if it completes.
                    if (longPressTimerId) { clearTimeout(longPressTimerId); longPressTimerId = null; }
                    longPressTimerId = setTimeout(() => {
                        svg.dispatchEvent(new CustomEvent('longpress', { detail: { clientX: t.clientX, clientY: t.clientY } }));
                        longPressTimerId = null;
                    }, touchHoldDuration);

                    if (isMobileMoveMode) {
                        legacy_handleTouchStart(e);
                    } else {
                        handleTouchStart(e);
                    }
                }
            }, { passive: false });

            // Ensure all touchend/touchcancel paths clear timers and cancel the hold overlay.
            const clearTouchHoldAndTimers = (ev) => {
                // Clear two- and multi-finger timers
                if (typeof twoFingerTimerId === 'number') { clearTimeout(twoFingerTimerId); twoFingerTimerId = null; } else { twoFingerTimerId = null; }
                if (multiFingerTimerId) { clearTimeout(multiFingerTimerId); multiFingerTimerId = null; }
                const wasTwoFinger = twoFingerHoldActive;
                twoFingerHoldActive = false;
                multiFingerHoldActive = false;
                // Cancel visual overlay
                cancelAllTouchVisuals();
                // Clear any pending long-press timer
                if (longPressTimerId) { clearTimeout(longPressTimerId); longPressTimerId = null; }
                // Remove transient single-touch move listener if present
                try {
                    if (activeSingleTouchMoveHandler) {
                        svg.removeEventListener('touchmove', activeSingleTouchMoveHandler);
                        activeSingleTouchMoveHandler = null;
                    }
                } catch (err) {
                    // ignore
                }
                // Restore pan button state if we temporarily set it for two-finger or MMB
                try {
                    const panBtn = document.getElementById('panToggleBtn');
                    if (panBtn) {
                        if (typeof panBtn.dataset._twoPrevActive !== 'undefined') {
                            const prev = panBtn.dataset._twoPrevActive === '1';
                            panBtn.classList.toggle('active', panMode || prev);
                            delete panBtn.dataset._twoPrevActive;
                        }
                        if (typeof panBtn.dataset._mmbPrevActive !== 'undefined') {
                            const prev2 = panBtn.dataset._mmbPrevActive === '1';
                            panBtn.classList.toggle('active', panMode || prev2);
                            delete panBtn.dataset._mmbPrevActive;
                        }
                    }
                } catch (err) {
                    // ignore
                }
                // If a temporary two-finger pan just ended, persist the view and avoid immediate clamp
                try {
                    if (wasTwoFinger) {
                        preservePanAfterDisable = true;
                        skipClampNextUpdate = true;
                        saveViewToConfig();
                    }
                } catch (err) {
                    // ignore
                }
                // Remove any transient single-touch move trackers
                // (We cannot remove by reference here; remove all listeners using a short-lived approach)
                // A safe approach: clone the svg and reattach persistent listeners is heavy-handed; instead rely on singleTouchMoveTracker removing itself when not needed.
            };

            svg.addEventListener('touchend', (e) => {
                // If this was a short tap while Move Mode is active and there was minimal movement,
                // treat it as a tap-to-place and move the selected room/outline to the tapped grid cell.
                try {
                    if (isMobileMoveMode && e.changedTouches && e.changedTouches.length === 1) {
                        const duration = performance.now() - touchTapStartTime;
                        const moved = touchTapMoved;
                        const t = e.changedTouches[0];
                        if (!moved && duration < 400) {
                            // Compute SVG-local coordinates taking pan/zoom into account
                            const svgEl = document.getElementById('mdsCanvas');
                            const rect = svgEl.getBoundingClientRect();
                            const clientX = t.clientX;
                            const clientY = t.clientY;
                            const svgX = (clientX - rect.left - view.panX) / view.zoom;
                            const svgY = (clientY - rect.top - view.panY) / view.zoom;
                            const cellSize = config.grid_cell_size;
                            const xBase = config.padding;
                            const yBase = computeContentYBase();
                            const gx = Math.floor((svgX - xBase) / cellSize);
                            const gy = Math.floor((svgY - yBase) / cellSize);
                            const deck = getCurrentDeck();
                            // Clamp into deck bounds
                            const clampedX = Math.max(-50, Math.min(deck.grid_width - 1, gx));
                            const clampedY = Math.max(-50, Math.min(deck.grid_height - 1, gy));

                            if (selectedRoomIndex !== -1 && deck.rooms[selectedRoomIndex]) {
                                const room = deck.rooms[selectedRoomIndex];
                                room.position = [clampedX, clampedY];
                                saveToLocalStorage();
                                render();
                            } else if (selectedOutlineIndex !== -1 && config.manual_outlines && config.manual_outlines[selectedOutlineIndex]) {
                                const outline = config.manual_outlines[selectedOutlineIndex];
                                outline.position = [clampedX, clampedY];
                                saveToLocalStorage();
                                render();
                            }
                        }
                    }
                } catch (err) {
                    console.error('tap-to-place error', err);
                }
                clearTouchHoldAndTimers(e);
            }, { passive: false });

            svg.addEventListener('touchcancel', (e) => {
                clearTouchHoldAndTimers(e);
            }, { passive: false });

            // Global touchmove handler to support immediate two-finger temporary pan
            svg.addEventListener('touchmove', (e) => {
                // Disable pinch-to-zoom
                if (e.touches.length === 2 && e.scale !== undefined) {
                    e.preventDefault();
                    return;
                }
                // Two-finger pan
                if (twoFingerHoldActive && e.touches && e.touches.length === 2) {
                    const t0 = e.touches[0];
                    const t1 = e.touches[1];
                    const cx = (t0.clientX + t1.clientX) / 2;
                    const cy = (t0.clientY + t1.clientY) / 2;
                    if (twoFingerPanStart && pinchStartCentroid) {
                        const deltaX = cx - pinchStartCentroid.x;
                        const deltaY = cy - pinchStartCentroid.y;
                        view.panX = twoFingerPanStart.startPanX + deltaX;
                        view.panY = twoFingerPanStart.startPanY + deltaY;
                        updateTransform();
                    }
                    e.preventDefault();
                    return;
                }
                // One-finger drag in Move Mode
                if (isMobileMoveMode && e.touches.length === 1) {
                    legacy_handleTouchMove(e);
                    e.preventDefault();
                    return;
                }
                // If user reduced touches below 2 while this listener is active, ensure we clear temporary state
                if (twoFingerHoldActive && (!e.touches || e.touches.length < 2)) {
                    twoFingerHoldActive = false;
                    cancelAllTouchVisuals();
                }
            }, { passive: false });

            // Mouse down: handle middle-button temporary pan, otherwise route to handlers
            svg.addEventListener('mousedown', (e) => {
                // Middle button (usually button === 1) -> temporary pan while held
                if (e.button === 1) {
                    const panBtn = document.getElementById('panToggleBtn');
                    if (panBtn) {
                        panBtn.dataset._mmbPrevActive = panBtn.classList.contains('active') ? '1' : '0';
                        panBtn.classList.add('active');
                    }

                    isPanning = true;
                    panStart.x = e.clientX;
                    panStart.y = e.clientY;
                    panStart.startPanX = view.panX;
                    panStart.startPanY = view.panY;

                    const onMiddleUp = (ev) => {
                        if (ev.button !== 1) return;
                        isPanning = false;
                        // preserve pan when MMB temporary-pan ends and avoid immediate clamp
                        preservePanAfterDisable = true;
                        skipClampNextUpdate = true;
                        saveViewToConfig();

                        if (panBtn) {
                            const prev = panBtn.dataset._mmbPrevActive === '1';
                            panBtn.classList.toggle('active', panMode || prev);
                            delete panBtn.dataset._mmbPrevActive;
                        }

                        document.removeEventListener('mouseup', onMiddleUp);
                    };
                    document.addEventListener('mouseup', onMiddleUp);
                    e.preventDefault();
                    return;
                }

                if (panMode) handleMouseDown(e); else legacy_handleMouseDown(e);
            });
            svg.addEventListener('mousemove', (e) => {
                // If middle button is held, prefer pan-aware movement
                if ((e.buttons & 4) !== 0) { handleMouseMove(e); return; }
                if (panMode) handleMouseMove(e); else legacy_handleMouseMove(e);
            });
            svg.addEventListener('mouseup',   (e) => { if (e.button === 1) return; if (panMode) handleMouseUp(e);   else legacy_handleMouseUp(e); });
            svg.addEventListener('mouseleave',(e) => { if (e.button === 1) return; if (panMode) handleMouseUp(e);   else legacy_handleMouseUp(e); });
            
                // Touch listeners handled above (two-finger / multi-finger hold logic).

            // Canvas control buttons
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const panToggleBtn = document.getElementById('panToggleBtn');

            const flashBtn = (btn) => { if (!btn) return; btn.classList.add('active'); setTimeout(()=>btn.classList.remove('active'), 140); };
            if (zoomInBtn) zoomInBtn.addEventListener('click', (e) => { flashBtn(zoomInBtn); zoomIn(); });
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', (e) => { flashBtn(zoomOutBtn); zoomOut(); });
            if (panToggleBtn) panToggleBtn.addEventListener('click', (e) => {
                // If Move Mode is active, cancel it before enabling persistent pan
                if (!panMode && isMobileMoveMode) {
                    toggleMobileMoveMode();
                }
                togglePanMode();
            });

            // Wheel - Ctrl+Wheel to zoom around cursor; otherwise scroll as usual
            const container = document.querySelector('.canvas-container');
            if (container) {
                // Only zoom the canvas when Ctrl+Wheel is used while hovering the canvas.
                // All other wheel events over the canvas are prevented to avoid page scroll.
                container.addEventListener('wheel', (e) => {
                    const rect = container.getBoundingClientRect();
                    // If hovering the canvas, intercept wheel.
                    if (isHoveringCanvas) {
                        if (e.ctrlKey) {
                            // Zoom anchored at cursor position
                            e.preventDefault();
                            const anchorX = e.clientX - rect.left;
                            const anchorY = e.clientY - rect.top;
                            const delta = e.deltaY > 0 ? 1/1.15 : 1.15;
                            setZoom(view.zoom * delta, anchorX, anchorY, true);
                        } else {
                            // Prevent page scroll while over canvas when Ctrl is not held
                            e.preventDefault();
                        }
                    }
                    // If not hovering canvas, do nothing (allow sidebar/page scrolling)
                }, { passive: false });
            }

            // Track hover over the SVG so Shift+Wheel while hovering can zoom
            if (svg) {
                svg.addEventListener('mouseenter', () => { isHoveringCanvas = true; });
                svg.addEventListener('mouseleave', () => { isHoveringCanvas = false; });

                // Middle-button panning handled in the main mousedown router above.
            }

            // Keyboard shortcuts: zoom/reset, P toggles pan/move
            document.addEventListener('keydown', (e) => {
                // Zoom keys (support both '=' and '+')
                if (e.key === '=' || e.key === '+') { zoomIn(); }
                else if (e.key === '-') { zoomOut(); }
                else if (e.key === '0') { view.zoom = 1; saveViewToConfig(); updateTransform(); render(); }

                // Toggle pan/move mode
                if (e.key && e.key.toLowerCase() === 'p') {
                    togglePanMode();
                }
            });
            // (no keyup handler needed now)
        }

        function syncUIFromConfig() {
            document.getElementById('shipName').value = config.name;
            document.getElementById('showGrid').checked = config.show_grid;
            document.getElementById('showArches').checked = config.show_arches;
            document.getElementById('autoOutline').checked = config.auto_outline;
            document.getElementById('cellSize').value = config.grid_cell_size;
            document.getElementById('bannerFontSize').value = config.banner_font_size || 24;
            document.getElementById('bannerFontOffsetX').value = config.banner_font_offset_x || 0;
            document.getElementById('bannerFontOffsetY').value = config.banner_font_offset_y || 0;
            // Sync banner/arches scale UI
            const bs = document.getElementById('bannerScale'); if (bs) bs.value = (typeof config.banner_scale !== 'undefined') ? config.banner_scale : 1.0;
            // archesScale UI removed; nothing to sync here.
            document.getElementById('outlinePadding').value = config.outline_padding;
            document.getElementById('outlineStyle').value = config.outline_style;
            document.getElementById('shipOutlineColor').value = config.ship_outline_color;
            document.getElementById('fontColor').value = config.text_color;
            document.getElementById('textShadow').checked = config.text_shadow || false;
            document.getElementById('showDeckName').checked = config.show_deck_name !== false;
            document.getElementById('colorPalette').value = config.color_palette || 'lcars';
            
            // Show/hide custom palette controls based on current palette
            const customControls = document.getElementById('customPaletteControls');
            if (customControls) {
                customControls.style.display = (config.color_palette === 'custom') ? 'block' : 'none';
            }
            
            // Update value displays (check if they exist first)
            const cellSizeValue = document.getElementById('cellSizeValue');
            if (cellSizeValue) cellSizeValue.textContent = config.grid_cell_size;
            
            const outlinePaddingValue = document.getElementById('outlinePaddingValue');
            if (outlinePaddingValue) outlinePaddingValue.textContent = config.outline_padding;
            
            currentPalette = COLOR_PALETTES[config.color_palette || 'lcars'];
            applyColorPalette();
            
            syncDeckUI();
        }

        function syncDeckUI() {
            const deck = getCurrentDeck();
            document.getElementById('deckName').value = deck.name;
            document.getElementById('gridWidth').value = deck.grid_width;
            document.getElementById('gridHeight').value = deck.grid_height;
        }

        function getCurrentDeck() {
            return config.decks[currentDeckIndex];
        }

        // Compute the Y offset where grid content starts (header area plus any
        // extra top space when banner/header grows). This mirrors the logic
        // in `render()` so mouse/touch coordinates align with drawn content.
        function computeContentYBase() {
            const bannerScale = (typeof config.banner_scale !== 'undefined') ? config.banner_scale : 1.0;
            const headerH = Math.max(24, Math.round(60 * bannerScale));
            const GRID_HEADER_BASE = 100;
            const baselineBottom = GRID_HEADER_BASE - 20; // original bottom used for rect anchoring
            const extraTop = Math.max(0, headerH - baselineBottom);
            return GRID_HEADER_BASE + extraTop;
        }

        // Move-button progress (used for three-finger hold). We render progress
        // by filling the Move Mode toggle button with a conic-gradient.
        let moveButtonProgressRaf = null;
        let moveButtonProgressStart = 0;
        let moveButtonProgressActive = false;
        let moveButtonPrevBackground = null;
        let moveButtonPrevColor = null;

        function startMoveButtonProgress(btn, duration = 1000, color = 'var(--lcars-orange)', onComplete = null) {
            if (!btn) return;
            cancelMoveButtonProgress(btn);
            moveButtonProgressActive = true;
            moveButtonProgressStart = performance.now();
            moveButtonPrevBackground = btn.style.background || '';
            moveButtonPrevColor = btn.style.color || '';

            function frame(now) {
                if (!moveButtonProgressActive) return;
                const elapsed = now - moveButtonProgressStart;
                const t = Math.min(1, elapsed / duration);
                const deg = Math.round(360 * t);
                // Fill using conic-gradient; fall back to solid color if unsupported
                btn.style.background = `conic-gradient(${color} 0deg ${deg}deg, transparent ${deg}deg 360deg)`;
                btn.style.color = '#000';
                if (t >= 1) {
                    moveButtonProgressActive = false;
                    if (typeof onComplete === 'function') onComplete();
                    return;
                }
                moveButtonProgressRaf = requestAnimationFrame(frame);
            }
            moveButtonProgressRaf = requestAnimationFrame(frame);
        }

        function cancelMoveButtonProgress(btn) {
            if (moveButtonProgressRaf) { cancelAnimationFrame(moveButtonProgressRaf); moveButtonProgressRaf = null; }
            moveButtonProgressActive = false;
            if (btn) {
                btn.style.background = moveButtonPrevBackground || '';
                btn.style.color = moveButtonPrevColor || '';
            }
            moveButtonPrevBackground = null;
            moveButtonPrevColor = null;
        }

        function cancelAllTouchVisuals() {
            const moveBtn = document.getElementById('moveModeToggle');
            cancelMoveButtonProgress(moveBtn);
        }

        function applyColorPalette() {
            // Update UI colors based on selected palette
            document.body.style.background = currentPalette.background;
            
            // Update CSS variables if needed
            const root = document.documentElement;
            root.style.setProperty('--lcars-orange', currentPalette.accent1);
            root.style.setProperty('--lcars-blue', currentPalette.border);
            root.style.setProperty('--lcars-skyblue', currentPalette.accent2);
            root.style.setProperty('--lcars-purple', currentPalette.accent2); // Use accent2 for secondary sections
            
            // Re-render outline list in case user is viewing it
            renderOutlineList();
        }

        function getPaletteColor(colorKey) {
            if (currentPalette.colors[colorKey]) {
                return currentPalette.colors[colorKey];
            }
            // Fallback to first color in palette
            return Object.values(currentPalette.colors)[0];
        }

        // Deck Management
        function renderDeckTabs() {
            const container = document.getElementById('deckTabs');
            container.innerHTML = '';
            
            config.decks.forEach((deck, index) => {
                const tab = document.createElement('div');
                tab.className = 'deck-tab' + (index === currentDeckIndex ? ' active' : '');
                tab.textContent = `Deck ${deck.number}`;
                tab.onclick = () => selectDeck(index);
                container.appendChild(tab);
            });
        }

        function selectDeck(index) {
            currentDeckIndex = index;
            selectedRoomIndex = -1;
            syncDeckUI();
            renderDeckTabs();
            renderRoomList();
            render();
        }

        function addDeck() {
            const newDeckNumber = config.decks.length + 1;
            const previousDeck = config.decks[config.decks.length - 1];
            
            // Create new deck - outlines are now global, not per-deck
            const newDeck = {
                number: newDeckNumber,
                name: `Deck ${newDeckNumber}`,
                grid_width: previousDeck.grid_width,
                grid_height: previousDeck.grid_height,
                rooms: [] // Start with empty rooms
            };
            
            const newDeckIndex = config.decks.length;
            
            // Update existing global outlines to include new deck in visibility
            if (config.manual_outlines) {
                config.manual_outlines.forEach(outline => {
                    if (outline.visible_on_decks && outline.visible_on_decks.length > 0) {
                        // Add new deck to visibility list
                        if (!outline.visible_on_decks.includes(newDeckIndex)) {
                            outline.visible_on_decks.push(newDeckIndex);
                        }
                    }
                });
            }
            
            config.decks.push(newDeck);
            currentDeckIndex = config.decks.length - 1;
            saveToLocalStorage();
            syncDeckUI();
            renderDeckTabs();
            renderRoomList();
            renderOutlineList();
            render();
        }

        function removeDeck() {
            if (config.decks.length <= 1) {
                alert('Cannot remove the last deck!');
                return;
            }
            if (confirm('Remove this deck and all its rooms?')) {
                const removedDeckIndex = currentDeckIndex;
                
                // Remove the deck
                config.decks.splice(currentDeckIndex, 1);
                currentDeckIndex = Math.max(0, currentDeckIndex - 1);
                
                // Renumber decks
                config.decks.forEach((deck, i) => deck.number = i + 1);
                
                // Update visible_on_decks for all global outlines
                if (config.manual_outlines) {
                    config.manual_outlines.forEach(outline => {
                        if (outline.visible_on_decks && Array.isArray(outline.visible_on_decks)) {
                            // Remove the deleted deck index and adjust remaining indices
                            outline.visible_on_decks = outline.visible_on_decks
                                .filter(deckIdx => deckIdx !== removedDeckIndex) // Remove deleted deck
                                .map(deckIdx => deckIdx > removedDeckIndex ? deckIdx - 1 : deckIdx); // Adjust indices
                            
                            // Outlines can be visible on zero decks - that's okay, user can re-enable later
                        }
                    });
                }
                
                saveToLocalStorage();
                syncDeckUI();
                renderDeckTabs();
                renderRoomList();
                renderOutlineList();
                render();
            }
        }

        // Room Management
        function addRoom() {
            openModal('Add New Room', [
                { id: 'newRoomName', label: 'Room Name', type: 'text', value: 'New Room' },
                { id: 'newRoomWidth', label: 'Width (grid cells)', type: 'number', value: 2, min: 1, max: 30 },
                { id: 'newRoomHeight', label: 'Height (grid cells)', type: 'number', value: 2, min: 1, max: 30 }
            ],
            () => {
                // Add callback
                const roomName = document.getElementById('newRoomName').value;
                const width = parseInt(document.getElementById('newRoomWidth').value);
                const height = parseInt(document.getElementById('newRoomHeight').value);
                const color = getRoomColor(roomName);
                
                getCurrentDeck().rooms.push({
                    name: roomName,
                    area: width * height,
                    size: [width, height],
                    position: [0, 0],
                    color: color,
                    rotation: 0
                });
                
                saveToLocalStorage();
                renderRoomList();
                render();
            },
            null,
            '‚ûï Add'); // No delete button, use "Add" text
        }

        function getRoomColor(roomName) {
            const nameLower = roomName.toLowerCase();
            const paletteColors = Object.values(currentPalette.colors);
            
            for (const [keyword, colorIndex] of Object.entries(ROOM_TYPE_COLORS)) {
                if (nameLower.includes(keyword)) {
                    // Use color index to get from current palette
                    return paletteColors[colorIndex % paletteColors.length];
                }
            }
            // Random color from current palette
            return paletteColors[Math.floor(Math.random() * paletteColors.length)];
        }

        function renderRoomList() {
            const container = document.getElementById('roomList');
            const rooms = getCurrentDeck().rooms;
            
            container.innerHTML = rooms.length === 0 
                ? '<div style="text-align:center;color:#666;padding:20px;">No rooms yet</div>'
                : '';
            
            rooms.forEach((room, index) => {
                const item = document.createElement('div');
                let className = 'room-item';
                if (index === selectedRoomIndex) className += ' selected';
                if (index === draggedRoomIndex) className += ' dragging';
                item.className = className;
                
                const hasPosition = room.position && room.size;
                const positionText = hasPosition 
                    ? `${room.size[0]}x${room.size[1]} @ (${room.position[0]},${room.position[1]})`
                    : `Area: ${room.area} (auto)`;
                
                item.innerHTML = `
                    <div class="room-item-header">
                        <div class="room-item-name">${room.name}</div>
                        <div class="room-color-indicator" style="background:${room.color}"></div>
                    </div>
                    <div class="room-item-stats">${positionText}</div>
                `;
                
                // Double-click to edit (desktop)
                item.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editRoom(index);
                });
                
                // Single click to select
                item.addEventListener('click', (e) => {
                    if (e.detail === 1) { // Only on single click, not double
                        selectRoom(index);
                    }
                });
                
                // Long press to edit (mobile) - 500ms
                let longPressTimer = null;
                item.addEventListener('touchstart', (e) => {
                    longPressTimer = setTimeout(() => {
                        editRoom(index);
                    }, 500);
                });
                
                item.addEventListener('touchend', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
                
                item.addEventListener('touchmove', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
                
                container.appendChild(item);
            });
            
            updateStatus();
            // Apply view transform (zoom/pan) after rendering
            updateTransform();
        }

        function selectRoom(index) {
            selectedRoomIndex = selectedRoomIndex === index ? -1 : index;
            renderRoomList();
            render(); // Update canvas to show selection highlight
        }

        function editRoom(index) {
            const room = getCurrentDeck().rooms[index];
            
            openModal('Edit Room', [
                { id: 'roomName', label: 'Room Name', type: 'text', value: room.name },
                { id: 'roomX', label: 'X Position (grid)', type: 'number', value: room.position ? room.position[0] : 0, min: -10, max: 40 },
                { id: 'roomY', label: 'Y Position (grid)', type: 'number', value: room.position ? room.position[1] : 0, min: -10, max: 40 },
                { id: 'roomWidth', label: 'Width (grid cells)', type: 'number', value: room.size ? room.size[0] : 2, min: 1, max: 30 },
                { id: 'roomHeight', label: 'Height (grid cells)', type: 'number', value: room.size ? room.size[1] : 2, min: 1, max: 30 },
                { id: 'roomColor', label: 'Background Color', type: 'color', value: room.color },
                { id: 'roomFontColor', label: 'Font Color', type: 'color', value: room.font_color || '#000000' },
                { id: 'roomFontSize', label: 'Font Size (px)', type: 'number', value: room.font_size || 14, min: 8, max: 32 },
                { id: 'roomFontOffsetX', label: 'Font Offset X (px)', type: 'number', value: room.font_offset ? room.font_offset[0] : 0, min: -100, max: 100 },
                { id: 'roomFontOffsetY', label: 'Font Offset Y (px)', type: 'number', value: room.font_offset ? room.font_offset[1] : 0, min: -100, max: 100 },
                { id: 'roomRotation', label: 'Rotation (degrees)', type: 'range', value: room.rotation || 0, min: 0, max: 360 }
            ], 
            () => {
                // Save callback
                room.name = document.getElementById('roomName').value;
                const x = parseInt(document.getElementById('roomX').value);
                const y = parseInt(document.getElementById('roomY').value);
                const width = parseInt(document.getElementById('roomWidth').value);
                const height = parseInt(document.getElementById('roomHeight').value);
                room.position = [x, y];
                room.size = [width, height];
                room.area = width * height;
                room.color = document.getElementById('roomColor').value;
                room.font_color = document.getElementById('roomFontColor').value;
                room.font_size = parseInt(document.getElementById('roomFontSize').value) || 14;
                room.font_offset = [
                    parseInt(document.getElementById('roomFontOffsetX').value) || 0,
                    parseInt(document.getElementById('roomFontOffsetY').value) || 0
                ];
                room.rotation = parseInt(document.getElementById('roomRotation').value) || 0;
                
                saveToLocalStorage();
                renderRoomList();
                render();
            },
            () => {
                // Delete callback
                getCurrentDeck().rooms.splice(index, 1);
                selectedRoomIndex = -1;
                saveToLocalStorage();
                renderRoomList();
                render();
            });
            
            // Add live preview for room editing
            setTimeout(() => {
                const liveUpdateRoom = () => {
                    room.name = document.getElementById('roomName').value;
                    const x = parseInt(document.getElementById('roomX').value) || 0;
                    const y = parseInt(document.getElementById('roomY').value) || 0;
                    const width = parseInt(document.getElementById('roomWidth').value) || room.size[0];
                    const height = parseInt(document.getElementById('roomHeight').value) || room.size[1];
                    room.position = [x, y];
                    room.size = [width, height];
                    room.area = width * height;
                    room.color = document.getElementById('roomColor').value;
                    room.font_color = document.getElementById('roomFontColor').value;
                    room.font_size = parseInt(document.getElementById('roomFontSize').value) || 14;
                    room.font_offset = [
                        parseInt(document.getElementById('roomFontOffsetX').value) || 0,
                        parseInt(document.getElementById('roomFontOffsetY').value) || 0
                    ];
                    room.rotation = parseInt(document.getElementById('roomRotation').value) || 0;
                    render();
                };
                
                document.getElementById('roomName').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomX').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomY').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomWidth').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomHeight').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomColor').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomFontColor').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomFontSize').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomFontOffsetX').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomFontOffsetY').addEventListener('input', liveUpdateRoom);
                document.getElementById('roomRotation').addEventListener('input', liveUpdateRoom);
            }, 100);
        }

        function clearAllRooms() {
            if (confirm('Remove all rooms from this deck?')) {
                getCurrentDeck().rooms = [];
                selectedRoomIndex = -1;
                saveToLocalStorage();
                renderRoomList();
                render();
            }
        }

        // Rendering
        function render() {
            const svg = document.getElementById('mdsCanvas');
            const deck = getCurrentDeck();
            const cellSize = config.grid_cell_size;
            const padding = config.padding;

            // Determine header height from bannerScale only (arches no longer scale independently)
            const bannerScale = (typeof config.banner_scale !== 'undefined') ? config.banner_scale : 1.0;
            const headerH = Math.max(24, Math.round(60 * bannerScale));

            const width = deck.grid_width * cellSize + 2 * padding;
            // Keep the original layout baseline for the grid header area (100px). If the
            // scaled header becomes taller than the baseline area, grow the svg and shift
            // the main content down by extraTop so the header is fully visible.
            const GRID_HEADER_BASE = 100;
            const baselineBottom = GRID_HEADER_BASE - 20; // original bottom used for rect anchoring
            const extraTop = Math.max(0, headerH - baselineBottom);
            const height = deck.grid_height * cellSize + GRID_HEADER_BASE + padding + extraTop;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Clear SVG
            svg.innerHTML = '';

            // Background
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('width', width);
            bg.setAttribute('height', height);
            bg.setAttribute('fill', currentPalette.background);
            svg.appendChild(bg);

            // yBase for content below header: shift down by extraTop if needed
            const contentYBase = GRID_HEADER_BASE + extraTop;
            // Compute rectY so the banner is vertically centered within the header area
            // (equal top and bottom margins). contentYBase is the distance from top
            // of canvas to the start of the grid area.
            const rectY = Math.round((contentYBase - headerH) / 2);

            // Manual Outlines (drawn first, behind everything - always check all decks)
            drawManualOutlines(svg, deck, padding, contentYBase);

            // LCARS Arches (placement uses headerH and rectY)
            if (config.show_arches) {
                drawLCARSArches(svg, width, height, headerH, rectY);
            }

            // Hull Outline
            if (config.auto_outline) {
                drawHullOutline(svg, deck, padding, contentYBase);
            }

            // Header (drawn after background/outlines so it overlays correctly).
            // Pass headerH and rectY so the header rect is vertically centered within
            // the header area (equal top/bottom margins).
            drawHeader(svg, deck, width, headerH, rectY);

            // Grid
            if (config.show_grid) {
                drawGrid(svg, deck, padding, contentYBase);
            }

            // Rooms
            drawRooms(svg, deck, padding, contentYBase);

            // Draw selection highlights
            drawSelectionHighlights(svg, deck, padding, contentYBase);

            updateStatus();
        }
        
        function drawSelectionHighlights(svg, deck, xBase, yBase) {
            const cellSize = config.grid_cell_size;
            
            // Highlight selected room
            if (selectedRoomIndex !== -1 && deck.rooms[selectedRoomIndex]) {
                const room = deck.rooms[selectedRoomIndex];
                if (room.position && room.size) {
                    const x = xBase + room.position[0] * cellSize;
                    const y = yBase + room.position[1] * cellSize;
                    const w = room.size[0] * cellSize;
                    const h = room.size[1] * cellSize;
                    
                    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    highlight.setAttribute('class', 'canvas-highlight');
                    highlight.setAttribute('x', x - 2);
                    highlight.setAttribute('y', y - 2);
                    highlight.setAttribute('width', w + 4);
                    highlight.setAttribute('height', h + 4);
                    svg.appendChild(highlight);
                }
            }
            
            // Highlight selected outline
            if (selectedOutlineIndex !== -1 && config.manual_outlines && config.manual_outlines[selectedOutlineIndex]) {
                const outline = config.manual_outlines[selectedOutlineIndex];
                // Only highlight if visible on current deck
                if (outline.visible_on_decks && outline.visible_on_decks.includes(currentDeckIndex)) {
                    if (outline.position && outline.size) {
                        const x = xBase + outline.position[0] * cellSize;
                        const y = yBase + outline.position[1] * cellSize;
                        const w = outline.size[0] * cellSize;
                        const h = outline.size[1] * cellSize;
                        
                        const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        highlight.setAttribute('class', 'canvas-highlight');
                        highlight.setAttribute('x', x - 2);
                        highlight.setAttribute('y', y - 2);
                        highlight.setAttribute('width', w + 4);
                        highlight.setAttribute('height', h + 4);
                        svg.appendChild(highlight);
                    }
                }
            }
        }

        // Accept rectY to position the header rect (top Y) so banner can be
        // vertically centered within the header area when the canvas grows.
        function drawHeader(svg, deck, width, headerHeight, rectY = null) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Title bar (rectangle position will be set after computing headerHeight so
            // we can anchor its bottom to the original baseline and grow the rect upward.)
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', config.padding);
            rect.setAttribute('width', width - 2 * config.padding);
            // temporary default; will be updated after computing headerHeight
            rect.setAttribute('height', 60);
            rect.setAttribute('fill', currentPalette.border);
            rect.setAttribute('rx', 20);
            g.appendChild(rect);
            
            // Determine vertical centering based on deck name visibility
            const showDeckName = config.show_deck_name !== false;
            // Banner font size remains controlled by the explicit banner_font_size setting.
            const bannerFontSize = config.banner_font_size || 24;
            // If caller supplied headerHeight (from render), use it; otherwise compute from banner_scale.
            if (typeof headerHeight === 'undefined' || headerHeight === null) {
                const bannerScale = (typeof config.banner_scale !== 'undefined') ? config.banner_scale : 1.0;
                headerHeight = Math.max(24, Math.round(60 * bannerScale));
            }
            // update rect height now that headerHeight is known
            rect.setAttribute('height', headerHeight);
            // If caller didn't provide rectY, fall back to previous baseline anchoring
            // behavior (keeping bottom anchored to baseline). Otherwise use rectY
            // which was computed in render() to vertically center the banner.
            if (rectY === null) {
                const GRID_HEADER_BASE = 100;
                const baselineBottom = GRID_HEADER_BASE - 20; // original bottom: 80
                const extraTop = Math.max(0, headerHeight - baselineBottom);
                rectY = baselineBottom + extraTop - headerHeight;
            }
            rect.setAttribute('y', rectY);
            const offsetX = config.banner_font_offset_x || 0;
            const offsetY = config.banner_font_offset_y || 0;
            const titleY = 20 + Math.round(headerHeight / 2) + (showDeckName ? -6 : 6);
            
            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', width / 2 + offsetX);
            // Position title relative to rectY so it stays centered within the header rect
            title.setAttribute('y', rectY + Math.round(headerHeight / 2) + (showDeckName ? -6 : 6) + offsetY);
            title.setAttribute('fill', config.text_color || currentPalette.background);
            title.setAttribute('font-family', 'Arial, sans-serif');
            title.setAttribute('font-size', bannerFontSize);
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('text-anchor', 'middle');
            title.textContent = `${config.name.toUpperCase()}`;
            applyTextShadow(title);
            g.appendChild(title);
            
            // Subtitle (only if show_deck_name is true)
            if (showDeckName) {
                const subtitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                subtitle.setAttribute('x', width / 2 + offsetX);
                const subtitleY = rectY + Math.round(headerHeight / 2) + Math.round(bannerFontSize * 0.7);
                subtitle.setAttribute('y', subtitleY + offsetY);
                subtitle.setAttribute('fill', config.text_color || currentPalette.background);
                subtitle.setAttribute('font-family', 'Arial, sans-serif');
                subtitle.setAttribute('font-size', Math.round(bannerFontSize * 0.6));
                subtitle.setAttribute('font-weight', 'bold');
                subtitle.setAttribute('text-anchor', 'middle');
                subtitle.textContent = `${deck.name.toUpperCase()}`;
                applyTextShadow(subtitle);
                g.appendChild(subtitle);
            }
            
            svg.appendChild(g);
        }

        function drawLCARSArches(svg, width, height, headerHeight, rectY = 0) {
            // Original simpler arches drawing ‚Äì no stroke/corner scaling.
            // Use rectY (top Y of header rect) to position arches so they follow
            // the banner when it's vertically centered.
            const topDotY = rectY - 10;
            const arcInnerY = rectY + headerHeight - 20;
            const arcBottomY = rectY + headerHeight;
            // Top left L-shape
            const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path1.setAttribute('d', `M 10 ${topDotY} L 10 ${arcInnerY} Q 10 ${arcBottomY} 20 ${arcBottomY} L 60 ${arcBottomY}`);
            path1.setAttribute('stroke', currentPalette.accent1);
            path1.setAttribute('stroke-width', 8);
            path1.setAttribute('fill', 'none');
            path1.setAttribute('stroke-linecap', 'round');
            svg.appendChild(path1);

            // Top right arch
            const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path2.setAttribute('d', `M ${width - 60} ${arcBottomY} L ${width - 20} ${arcBottomY} Q ${width - 10} ${arcBottomY} ${width - 10} ${arcInnerY} L ${width - 10} ${topDotY}`);
            path2.setAttribute('stroke', currentPalette.accent2);
            path2.setAttribute('stroke-width', 8);
            path2.setAttribute('fill', 'none');
            path2.setAttribute('stroke-linecap', 'round');
            svg.appendChild(path2);

            // Corner circles
            const paletteColors = Object.values(currentPalette.colors);
            const corners = [
                [15, rectY - 5, paletteColors[0]],
                [width - 15, rectY - 5, paletteColors[1] || paletteColors[0]],
                [15, height - 15, paletteColors[2] || paletteColors[0]],
                [width - 15, height - 15, paletteColors[3] || paletteColors[0]]
            ];

            corners.forEach(([cx, cy, color]) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', 5);
                circle.setAttribute('fill', color);
                svg.appendChild(circle);
            });
        }

        function drawManualOutlines(svg, deck, xBase, yBase) {
            const cellSize = config.grid_cell_size;
            
            // Use global outlines array and filter by visibility
            const allOutlines = [];
            if (config.manual_outlines) {
                config.manual_outlines.forEach(outline => {
                    // Ensure visible_on_decks exists and is an array
                    if (!outline.visible_on_decks || !Array.isArray(outline.visible_on_decks)) {
                        outline.visible_on_decks = [];
                    }
                    
                    // Check if this outline should be visible on the current deck
                    const visibleDecks = outline.visible_on_decks;
                    if (visibleDecks.includes(currentDeckIndex)) {
                        allOutlines.push(outline);
                    }
                });
            }
            
            console.log(`Deck ${currentDeckIndex + 1}: Found ${allOutlines.length} visible outlines`);
            
            // Sort by z-index
            const sorted = [...allOutlines].sort((a, b) => (a.z_index || 0) - (b.z_index || 0));
            
            sorted.forEach(outline => {
                const x = xBase + outline.position[0] * cellSize;
                const y = yBase + outline.position[1] * cellSize;
                const w = outline.size[0] * cellSize;
                const h = outline.size[1] * cellSize;
                
                // Check if any rooms overlap this outline shape
                let hasRoomOverlap = false;
                deck.rooms.forEach(room => {
                    if (room.position && room.size) {
                        const [rx, ry] = room.position;
                        const [rw, rh] = room.size;
                        
                        // Check for overlap
                        const outlineLeft = outline.position[0];
                        const outlineRight = outline.position[0] + outline.size[0];
                        const outlineTop = outline.position[1];
                        const outlineBottom = outline.position[1] + outline.size[1];
                        
                        const roomLeft = rx;
                        const roomRight = rx + rw;
                        const roomTop = ry;
                        const roomBottom = ry + rh;
                        
                        if (!(outlineRight <= roomLeft || outlineLeft >= roomRight || 
                              outlineBottom <= roomTop || outlineTop >= roomBottom)) {
                            hasRoomOverlap = true;
                        }
                    }
                });
                
                // Determine if border should be shown
                const showBorder = outline.show_border !== false && !hasRoomOverlap;
                const rotation = outline.rotation || 0;
                
                if (outline.type === 'rect') {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x);
                    rect.setAttribute('y', y);
                    rect.setAttribute('width', w);
                    rect.setAttribute('height', h);
                    rect.setAttribute('fill', outline.color);
                    if (showBorder) {
                        rect.setAttribute('stroke', currentPalette.border);
                        rect.setAttribute('stroke-width', 2);
                    }
                    if (rotation !== 0) {
                        rect.setAttribute('transform', `rotate(${rotation} ${x + w/2} ${y + h/2})`);
                    }
                    svg.appendChild(rect);
                } else if (outline.type === 'ellipse') {
                    const ellipse = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    ellipse.setAttribute('cx', x + w/2);
                    ellipse.setAttribute('cy', y + h/2);
                    ellipse.setAttribute('rx', w/2);
                    ellipse.setAttribute('ry', h/2);
                    ellipse.setAttribute('fill', outline.color);
                    if (showBorder) {
                        ellipse.setAttribute('stroke', currentPalette.border);
                        ellipse.setAttribute('stroke-width', 2);
                    }
                    if (rotation !== 0) {
                        ellipse.setAttribute('transform', `rotate(${rotation} ${x + w/2} ${y + h/2})`);
                    }
                    svg.appendChild(ellipse);
                } else if (outline.type === 'triangle') {
                    const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    // Create triangle pointing up with top vertex at center-top, bottom two at corners
                    const points = `${x + w/2},${y} ${x + w},${y + h} ${x},${y + h}`;
                    triangle.setAttribute('points', points);
                    triangle.setAttribute('fill', outline.color);
                    if (showBorder) {
                        triangle.setAttribute('stroke', currentPalette.border);
                        triangle.setAttribute('stroke-width', 2);
                    }
                    if (rotation !== 0) {
                        triangle.setAttribute('transform', `rotate(${rotation} ${x + w/2} ${y + h/2})`);
                    }
                    svg.appendChild(triangle);
                }
            });
        }

        function drawHullOutline(svg, deck, xBase, yBase) {
            const cellSize = config.grid_cell_size;
            const grid = Array(deck.grid_height).fill().map(() => Array(deck.grid_width).fill(false));
            
            // Mark occupied cells
            deck.rooms.forEach(room => {
                if (room.position && room.size) {
                    const [x, y] = room.position;
                    const [w, h] = room.size;
                    for (let dy = 0; dy < h; dy++) {
                        for (let dx = 0; dx < w; dx++) {
                            if (y + dy < deck.grid_height && x + dx < deck.grid_width) {
                                grid[y + dy][x + dx] = true;
                            }
                        }
                    }
                }
            });
            
            // Draw thick borders - only round corners at hull edges
            const borderThickness = cellSize * config.outline_padding;
            
            for (let y = 0; y < deck.grid_height; y++) {
                for (let x = 0; x < deck.grid_width; x++) {
                    if (grid[y][x]) {
                        const px = xBase + x * cellSize;
                        const py = yBase + y * cellSize;
                        
                        // Check neighbors to determine if this is an edge cell
                        const hasTop = y > 0 && grid[y-1][x];
                        const hasBottom = y < deck.grid_height - 1 && grid[y+1][x];
                        const hasLeft = x > 0 && grid[y][x-1];
                        const hasRight = x < deck.grid_width - 1 && grid[y][x+1];
                        
                        // Only apply corner radius if this is an outer corner
                        let cornerRadius = 0;
                        if (config.outline_style === 'rounded') {
                            // Check if this is a corner cell
                            const isTopLeft = !hasTop && !hasLeft;
                            const isTopRight = !hasTop && !hasRight;
                            const isBottomLeft = !hasBottom && !hasLeft;
                            const isBottomRight = !hasBottom && !hasRight;
                            
                            if (isTopLeft || isTopRight || isBottomLeft || isBottomRight) {
                                cornerRadius = cellSize * 0.2;
                            }
                        }
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', px);
                        rect.setAttribute('y', py);
                        rect.setAttribute('width', cellSize);
                        rect.setAttribute('height', cellSize);
                        rect.setAttribute('rx', cornerRadius);
                        rect.setAttribute('fill', 'none');
                        rect.setAttribute('stroke', config.ship_outline_color);
                        rect.setAttribute('stroke-width', borderThickness);
                        svg.appendChild(rect);
                    }
                }
            }
        }

        function drawGrid(svg, deck, xBase, yBase) {
            const cellSize = config.grid_cell_size;
            
            // Horizontal lines
            for (let y = 0; y <= deck.grid_height; y++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', xBase);
                line.setAttribute('y1', yBase + y * cellSize);
                line.setAttribute('x2', xBase + deck.grid_width * cellSize);
                line.setAttribute('y2', yBase + y * cellSize);
                line.setAttribute('stroke', currentPalette.grid);
                line.setAttribute('stroke-width', 1);
                svg.appendChild(line);
            }
            
            // Vertical lines
            for (let x = 0; x <= deck.grid_width; x++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', xBase + x * cellSize);
                line.setAttribute('y1', yBase);
                line.setAttribute('x2', xBase + x * cellSize);
                line.setAttribute('y2', yBase + deck.grid_height * cellSize);
                line.setAttribute('stroke', currentPalette.grid);
                line.setAttribute('stroke-width', 1);
                svg.appendChild(line);
            }
        }

        function drawRooms(svg, deck, xBase, yBase) {
            const cellSize = config.grid_cell_size;
            
            deck.rooms.forEach((room, index) => {
                if (!room.position || !room.size) return;
                
                const [x, y] = room.position;
                const [w, h] = room.size;
                
                const px = xBase + x * cellSize;
                const py = yBase + y * cellSize;
                const width = w * cellSize;
                const height = h * cellSize;
                
                // Room rectangle
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', px + 2);
                rect.setAttribute('y', py + 2);
                rect.setAttribute('width', width - 4);
                rect.setAttribute('height', height - 4);
                rect.setAttribute('fill', room.color);
                rect.setAttribute('stroke', currentPalette.border);
                rect.setAttribute('stroke-width', 2);
                rect.setAttribute('rx', 8);
                
                // Apply rotation if set
                const rotation = room.rotation || 0;
                if (rotation !== 0) {
                    const centerX = px + width / 2;
                    const centerY = py + height / 2;
                    rect.setAttribute('transform', `rotate(${rotation} ${centerX} ${centerY})`);
                }
                
                svg.appendChild(rect);
                
                // Room label with custom font color, offset, and size
                const fontColor = room.font_color || null;
                const fontSize = room.font_size || 14;
                const offsetX = room.font_offset ? room.font_offset[0] : 0;
                const offsetY = room.font_offset ? room.font_offset[1] : 0;
                drawWrappedText(svg, room.label || room.name, px + width / 2, py + height / 2, width - 10, height - 10, fontColor, offsetX, offsetY, fontSize, rotation);
            });
        }

        function drawWrappedText(svg, text, centerX, centerY, maxWidth, maxHeight, fontColor = null, offsetX = 0, offsetY = 0, fontSize = null, rotation = 0) {
            const actualFontSize = fontSize || 14;
            const words = text.toUpperCase().split(' ');
            const charWidth = actualFontSize * 0.6;
            const maxCharsPerLine = Math.floor(maxWidth / charWidth);
            const lineHeight = actualFontSize * 1.2;
            const maxLines = Math.floor(maxHeight / lineHeight);
            
            let lines = [];
            let currentLine = [];
            
            words.forEach(word => {
                const testLine = [...currentLine, word].join(' ');
                if (testLine.length <= maxCharsPerLine) {
                    currentLine.push(word);
                } else {
                    if (currentLine.length > 0) {
                        lines.push(currentLine.join(' '));
                    }
                    currentLine = [word];
                }
            });
            
            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }
            
            // Limit lines
            if (lines.length > maxLines && maxLines > 0) {
                lines = lines.slice(0, maxLines);
                if (maxLines > 0) {
                    lines[maxLines - 1] = lines[maxLines - 1].substring(0, maxCharsPerLine - 3) + '...';
                }
            }
            
            const totalHeight = lines.length * lineHeight;
            const startY = centerY - totalHeight / 2 + lineHeight / 2;
            
            // Apply offsets
            const finalCenterX = centerX + offsetX;
            const finalStartY = startY + offsetY;
            
            // Create a group for rotation
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            if (rotation !== 0) {
                group.setAttribute('transform', `rotate(${rotation} ${centerX} ${centerY})`);
            }
            
            lines.forEach((line, i) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', finalCenterX);
                text.setAttribute('y', finalStartY + i * lineHeight);
                text.setAttribute('fill', fontColor || '#000000');
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.setAttribute('font-size', actualFontSize);
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('text-anchor', 'middle');
                text.textContent = line;
                applyTextShadow(text);
                group.appendChild(text);
            });
            
            svg.appendChild(group);
        }

        function updateStatus() {
            const deck = getCurrentDeck();
            const totalCells = deck.grid_width * deck.grid_height;
            let occupiedCells = 0;
            
            deck.rooms.forEach(room => {
                if (room.size) {
                    occupiedCells += room.size[0] * room.size[1];
                }
            });
            
            // Coverage calculation removed ‚Äî not shown to user.
            
            document.getElementById('statusDeck').textContent = `Deck: ${deck.number} (${deck.name})`;
            document.getElementById('statusRooms').textContent = `Rooms: ${deck.rooms.length}`;
        }

        function applyTextShadow(textElement) {
            if (config.text_shadow) {
                // Create contrasting drop shadow (white or black based on text color)
                const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                const filterId = 'textShadow_' + Math.random().toString(36).substr(2, 9);
                filter.setAttribute('id', filterId);
                filter.setAttribute('x', '-50%');
                filter.setAttribute('y', '-50%');
                filter.setAttribute('width', '200%');
                filter.setAttribute('height', '200%');
                
                const feDropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'feDropShadow');
                feDropShadow.setAttribute('dx', '1');
                feDropShadow.setAttribute('dy', '1');
                feDropShadow.setAttribute('stdDeviation', '1.5');
                feDropShadow.setAttribute('flood-color', '#ffffff');
                feDropShadow.setAttribute('flood-opacity', '0.8');
                
                filter.appendChild(feDropShadow);
                
                const svg = document.getElementById('mdsCanvas');
                let defs = svg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    svg.insertBefore(defs, svg.firstChild);
                }
                defs.appendChild(filter);
                
                textElement.setAttribute('filter', `url(#${filterId})`);
            }
        }

        function toggleAccordion(element) {
            const content = element.nextElementSibling;
            element.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }

        // Modal Dialog Functions
        let modalContext = null;

        function openModal(title, fields, onSave, onDelete, saveButtonText = 'üíæ Save') {
            document.getElementById('modalTitle').textContent = title;
            const modalBody = document.getElementById('modalBody');
            modalBody.innerHTML = '';
            
            // Create form fields
            fields.forEach(field => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'modal-field';
                
                const label = document.createElement('label');
                label.textContent = field.label;
                fieldDiv.appendChild(label);
                
                if (field.type === 'custom') {
                    // Custom HTML content
                    const customDiv = document.createElement('div');
                    customDiv.innerHTML = field.html;
                    fieldDiv.appendChild(customDiv);
                } else if (field.type === 'select') {
                    const select = document.createElement('select');
                    select.id = field.id;
                    field.options.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        if (opt.value === field.value) option.selected = true;
                        select.appendChild(option);
                    });
                    fieldDiv.appendChild(select);
                } else if (field.type === 'range' && field.showInput !== false) {
                    // Dual slider + number input for range fields (like rotation)
                    const container = document.createElement('div');
                    container.style.display = 'flex';
                    container.style.gap = '10px';
                    container.style.alignItems = 'center';
                    
                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.id = field.id;
                    slider.value = field.value || 0;
                    if (field.min !== undefined) slider.min = field.min;
                    if (field.max !== undefined) slider.max = field.max;
                    if (field.step !== undefined) slider.step = field.step;
                    slider.style.flex = '1';
                    
                    const numberInput = document.createElement('input');
                    numberInput.type = 'number';
                    numberInput.id = field.id + '_input';
                    numberInput.value = field.value || 0;
                    if (field.min !== undefined) numberInput.min = field.min;
                    if (field.max !== undefined) numberInput.max = field.max;
                    if (field.step !== undefined) numberInput.step = field.step;
                    numberInput.style.width = '80px';
                    
                    // Sync slider and input
                    slider.addEventListener('input', (e) => {
                        numberInput.value = e.target.value;
                    });
                    numberInput.addEventListener('input', (e) => {
                        slider.value = e.target.value;
                    });
                    
                    container.appendChild(slider);
                    container.appendChild(numberInput);
                    fieldDiv.appendChild(container);
                } else {
                    const input = document.createElement('input');
                    input.type = field.type || 'text';
                    input.id = field.id;
                    input.value = field.value || '';
                    if (field.min !== undefined) input.min = field.min;
                    if (field.max !== undefined) input.max = field.max;
                    if (field.step !== undefined) input.step = field.step;
                    fieldDiv.appendChild(input);
                }
                
                modalBody.appendChild(fieldDiv);
            });
            
            // Store callbacks
            modalContext = { onSave, onDelete };
            
            // Update button text
            document.getElementById('modalSaveBtn').textContent = saveButtonText;
            
            // Show/hide delete button
            const deleteBtn = document.getElementById('modalDeleteBtn');
            deleteBtn.style.display = onDelete ? 'block' : 'none';
            
            // Reset modal position
            const dialog = document.querySelector('.modal-dialog');
            dialog.style.position = 'relative';
            dialog.style.left = '0';
            dialog.style.top = '0';
            
            // Setup modal dragging
            setupModalDrag();
            
            // Show modal
            document.getElementById('modalOverlay').classList.add('active');
        }

        let modalDragState = { isDragging: false, startX: 0, startY: 0, initialX: 0, initialY: 0 };

        function setupModalDrag() {
            const header = document.querySelector('.modal-header');
            const dialog = document.querySelector('.modal-dialog');
            
            // Remove old listeners if any
            header.onmousedown = null;
            
            header.onmousedown = (e) => {
                modalDragState.isDragging = true;
                const style = window.getComputedStyle(dialog);
                const matrix = new DOMMatrix(style.transform);
                modalDragState.initialX = matrix.m41 || 0;
                modalDragState.initialY = matrix.m42 || 0;
                modalDragState.startX = e.clientX;
                modalDragState.startY = e.clientY;
                e.preventDefault();
            };
            
            document.onmousemove = (e) => {
                if (!modalDragState.isDragging) return;
                
                const dx = e.clientX - modalDragState.startX;
                const dy = e.clientY - modalDragState.startY;
                
                dialog.style.transform = `translate(${modalDragState.initialX + dx}px, ${modalDragState.initialY + dy}px)`;
            };
            
            document.onmouseup = () => {
                if (modalDragState.isDragging) {
                    modalDragState.isDragging = false;
                }
            };
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
            modalContext = null;
            
            // Clean up drag listeners
            const header = document.querySelector('.modal-header');
            if (header) header.onmousedown = null;
        }

        function modalSave() {
            if (modalContext && modalContext.onSave) {
                modalContext.onSave();
            }
            closeModal();
        }

        function modalDelete() {
            if (modalContext && modalContext.onDelete) {
                if (confirm('Are you sure you want to delete this item?')) {
                    modalContext.onDelete();
                    closeModal();
                }
            }
        }

        // Mobile Move Mode Functions
        function toggleMobileMoveMode() {
            // Toggle move mode and ensure all transient touch/pan state is cleared
            isMobileMoveMode = !isMobileMoveMode;
            const buttons = document.getElementById('mobileMoveButtons');
            const toggleBtn = document.getElementById('moveModeToggle');

            // Cancel any visual progress / timers and transient two-finger pan
            try {
                cancelAllTouchVisuals();
            } catch (err) {}
            try { if (twoFingerTimerId && typeof twoFingerTimerId === 'number') { clearTimeout(twoFingerTimerId); } twoFingerTimerId = null; } catch (err) {}
            try { if (multiFingerTimerId && typeof multiFingerTimerId === 'number') { clearTimeout(multiFingerTimerId); } multiFingerTimerId = null; } catch (err) {}
            try { if (longPressTimerId) { clearTimeout(longPressTimerId); } longPressTimerId = null; } catch (err) {}
            twoFingerHoldActive = false;
            multiFingerHoldActive = false;
            isPinching = false;
            // Remove transient single-touch move listener if present
            try {
                const svg = document.getElementById('mdsCanvas');
                if (activeSingleTouchMoveHandler && svg) {
                    svg.removeEventListener('touchmove', activeSingleTouchMoveHandler);
                    activeSingleTouchMoveHandler = null;
                }
            } catch (err) {}

            if (isMobileMoveMode) {
                buttons.classList.add('active');
                toggleBtn.classList.add('active');
                toggleBtn.textContent = 'üîì Exit Move Mode';
                // When entering Move Mode, ensure persistent pan mode is OFF
                if (panMode) {
                    panMode = false;
                    const panBtn = document.getElementById('panToggleBtn');
                    if (panBtn) panBtn.classList.toggle('active', false);
                    const svg = document.getElementById('mdsCanvas');
                    if (svg) svg.style.cursor = 'default';
                    preservePanAfterDisable = true;
                    skipClampNextUpdate = true;
                    userHasPannedView = true;
                }
                // Disable default touch actions while moving items
                const svgElm = document.getElementById('mdsCanvas');
                if (svgElm) svgElm.style.touchAction = 'none';
                // Auto-select first item when entering move mode
                if (mobileSelectionMode === 'rooms') {
                    const rooms = getCurrentDeck().rooms;
                    if (rooms.length > 0) {
                        selectedRoomIndex = 0;
                        selectedOutlineIndex = -1;
                    }
                } else {
                    if (config.manual_outlines && config.manual_outlines.length > 0) {
                        selectedOutlineIndex = 0;
                        selectedRoomIndex = -1;
                    }
                }
            } else {
                buttons.classList.remove('active');
                toggleBtn.classList.remove('active');
                toggleBtn.textContent = 'üîí Move Mode';
                // Restore default touch behavior on the SVG when leaving move mode
                const svgElm = document.getElementById('mdsCanvas');
                if (svgElm) svgElm.style.touchAction = 'auto';
                selectedRoomIndex = -1;
                selectedOutlineIndex = -1;
            }

            // Re-render UI lists and canvas to reflect selection changes
            renderRoomList();
            renderOutlineList();
            render();

            // Ensure toolbar/status/controls remain visible (defensive)
            const toolbar = document.querySelector('.toolbar');
            const status = document.querySelector('.status-bar');
            const canvasControls = document.getElementById('canvasControls');
            const menuToggle = document.getElementById('menuToggle');
            if (toolbar) toolbar.style.display = 'flex';
            if (status) status.style.display = 'flex';
            if (canvasControls) canvasControls.style.display = 'inline-flex';
            if (menuToggle) menuToggle.style.display = 'flex';
        }
        
        function toggleMobileMode() {
            if (!isMobileMoveMode) return;
            
            // Toggle between rooms and outlines
            mobileSelectionMode = mobileSelectionMode === 'rooms' ? 'outlines' : 'rooms';
            const btn = document.getElementById('mobileToggleMode');
            btn.textContent = mobileSelectionMode === 'rooms' ? 'üì¶ Rooms' : 'üî∑ Outlines';
            
            // Clear dragged indices
            draggedRoomIndex = -1;
            draggedOutlineIndex = -1;
            
            // Select first item in new mode
            if (mobileSelectionMode === 'rooms') {
                const rooms = getCurrentDeck().rooms;
                if (rooms.length > 0) {
                    selectedRoomIndex = 0;
                    selectedOutlineIndex = -1;
                } else {
                    selectedRoomIndex = -1;
                }
            } else {
                if (config.manual_outlines && config.manual_outlines.length > 0) {
                    selectedOutlineIndex = 0;
                    selectedRoomIndex = -1;
                } else {
                    selectedOutlineIndex = -1;
                }
            }
            renderRoomList();
            renderOutlineList();
            render();
        }
        
        function cycleMobilePrev() {
            if (!isMobileMoveMode) return;
            
            if (mobileSelectionMode === 'rooms') {
                const rooms = getCurrentDeck().rooms;
                if (rooms.length === 0) return;
                selectedRoomIndex = selectedRoomIndex <= 0 ? rooms.length - 1 : selectedRoomIndex - 1;
                selectedOutlineIndex = -1;
                draggedOutlineIndex = -1;
            } else {
                if (!config.manual_outlines || config.manual_outlines.length === 0) return;
                selectedOutlineIndex = selectedOutlineIndex <= 0 ? config.manual_outlines.length - 1 : selectedOutlineIndex - 1;
                selectedRoomIndex = -1;
                draggedRoomIndex = -1;
            }
            renderRoomList();
            renderOutlineList();
            render();
        }
        
        function cycleMobileNext() {
            if (!isMobileMoveMode) return;
            
            if (mobileSelectionMode === 'rooms') {
                const rooms = getCurrentDeck().rooms;
                if (rooms.length === 0) return;
                selectedRoomIndex = selectedRoomIndex >= rooms.length - 1 ? 0 : selectedRoomIndex + 1;
                selectedOutlineIndex = -1;
                draggedOutlineIndex = -1;
            } else {
                if (!config.manual_outlines || config.manual_outlines.length === 0) return;
                selectedOutlineIndex = selectedOutlineIndex >= config.manual_outlines.length - 1 ? 0 : selectedOutlineIndex + 1;
                selectedRoomIndex = -1;
                draggedRoomIndex = -1;
            }
            renderRoomList();
            renderOutlineList();
            render();
        }

        // Help Modal Functions
        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // Mobile Menu Toggle
        function toggleMobileMenu() {
            const sidebar = document.querySelector('.sidebar');
            const toggle = document.getElementById('menuToggle');
            const isOpen = sidebar.classList.toggle('open');
            toggle.classList.toggle('sidebar-open', isOpen);
            
            // Change icon based on state
            toggle.textContent = isOpen ? '√ó' : '‚Ä∫';
        }

        // Close mobile menu when clicking outside on mobile
        document.addEventListener('click', (e) => {
            const sidebar = document.querySelector('.sidebar');
            const toggle = document.getElementById('menuToggle');
            
            if (window.innerWidth <= 768 && sidebar.classList.contains('open')) {
                if (!sidebar.contains(e.target) && e.target !== toggle) {
                    sidebar.classList.remove('open');
                    toggle.textContent = '‚Ä∫';
                }
            }
        });

        // Drag and Drop Functions
        function handleMouseDown(event) {
            const deck = getCurrentDeck();
            const svg = document.getElementById('mdsCanvas');
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            // Convert from screen (transformed) coords back to SVG logical coords
            // (legacy behavior: invert scale only; pan is handled by bounding rect).
            const svgX = mouseX / view.zoom;
            const svgY = mouseY / view.zoom;

            // If in pan mode, start panning instead of initiating drag on objects
            if (panMode && !isMobileMoveMode) {
                isPanning = true;
                panStart.x = event.clientX;
                panStart.y = event.clientY;
                panStart.startPanX = view.panX;
                panStart.startPanY = view.panY;
                svg.style.cursor = 'grabbing';
                event.preventDefault();
                // if user starts panning, we no longer preserve post-disable pan state
                preservePanAfterDisable = false;
                return;
            }

            // Convert to grid coordinates
            const cellSize = config.grid_cell_size;
            const xBase = config.padding;
            const yBase = computeContentYBase(); // Header height
            
            const gridX = Math.floor((svgX - xBase) / cellSize);
            const gridY = Math.floor((svgY - yBase) / cellSize);
            
            // On mobile in move mode, ONLY drag the cycle-selected item
            // Ignore which object is actually touched - always drag the selected one
            if (isMobileMoveMode) {
                // Drag selected room
                if (selectedRoomIndex !== -1 && deck.rooms[selectedRoomIndex]) {
                    const room = deck.rooms[selectedRoomIndex];
                    if (room.position && room.size) {
                        draggedRoomIndex = selectedRoomIndex;
                        isDragging = true;
                        const [rx, ry] = room.position;
                        dragOffset.x = gridX - rx;
                        dragOffset.y = gridY - ry;
                        return;
                    }
                }
                
                // Drag selected outline
                if (selectedOutlineIndex !== -1 && config.manual_outlines && config.manual_outlines[selectedOutlineIndex]) {
                    const outline = config.manual_outlines[selectedOutlineIndex];
                    if (outline.position && outline.size) {
                        draggedOutlineIndex = selectedOutlineIndex;
                        isDragging = true;
                        const [ox, oy] = outline.position;
                        dragOffset.x = gridX - ox;
                        dragOffset.y = gridY - oy;
                        return;
                    }
                }
                
                // No selected item - do nothing
                return;
            }
            
            // Desktop behavior: Check rooms FIRST (higher priority than outlines)
            for (let i = deck.rooms.length - 1; i >= 0; i--) {
                const room = deck.rooms[i];
                if (room.position && room.size) {
                    const [rx, ry] = room.position;
                    const [rw, rh] = room.size;
                    
                    if (gridX >= rx && gridX < rx + rw && gridY >= ry && gridY < ry + rh) {
                        draggedRoomIndex = i;
                        isDragging = true;
                        dragOffset.x = gridX - rx;
                        dragOffset.y = gridY - ry;
                        selectedRoomIndex = i;
                        selectedOutlineIndex = -1; // Deselect outline when selecting room
                        renderRoomList();
                        renderOutlineList();
                        render();
                        return;
                    }
                }
            }
            
            // Check manual outlines (lower priority) - use global outlines
            if (config.manual_outlines && config.manual_outlines.length > 0) {
                for (let i = config.manual_outlines.length - 1; i >= 0; i--) {
                    const outline = config.manual_outlines[i];
                    // Only allow dragging if visible on current deck
                    if (outline.visible_on_decks && outline.visible_on_decks.includes(currentDeckIndex)) {
                        if (outline.position && outline.size) {
                            const [ox, oy] = outline.position;
                            const [ow, oh] = outline.size;
                            
                            if (gridX >= ox && gridX < ox + ow && gridY >= oy && gridY < oy + oh) {
                                draggedOutlineIndex = i;
                                isDragging = true;
                                dragOffset.x = gridX - ox;
                                dragOffset.y = gridY - oy;
                                selectedOutlineIndex = i;
                                selectedRoomIndex = -1; // Deselect room when selecting outline
                                renderOutlineList();
                                renderRoomList();
                                render();
                                return;
                            }
                        }
                    }
                }
            }
            
            // Clicked on empty space - deselect everything
            selectedRoomIndex = -1;
            selectedOutlineIndex = -1;
            renderRoomList();
            renderOutlineList();
            render();
        }

        function handleMouseMove(event) {
            // Handle panning first
            if (isPanning) {
                const dx = event.clientX - panStart.x;
                const dy = event.clientY - panStart.y;
                view.panX = panStart.startPanX + dx;
                view.panY = panStart.startPanY + dy;
                updateTransform();
                return;
            }
            if (!isDragging) return;
            
            const deck = getCurrentDeck();
            const svg = document.getElementById('mdsCanvas');
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const svgX = mouseX / view.zoom;
            const svgY = mouseY / view.zoom;
            
            const cellSize = config.grid_cell_size;
            const xBase = config.padding;
            const yBase = computeContentYBase();
            
            const gridX = Math.floor((svgX - xBase) / cellSize);
            const gridY = Math.floor((svgY - yBase) / cellSize);
            
            // Handle outline dragging
            if (draggedOutlineIndex !== -1) {
                const outline = config.manual_outlines[draggedOutlineIndex];
                // Allow outlines to flow off the grid (no boundary constraints)
                const newX = gridX - dragOffset.x;
                const newY = gridY - dragOffset.y;
                outline.position = [newX, newY];
                render();
                return;
            }
            
            // Handle room dragging
            if (draggedRoomIndex !== -1) {
                const room = deck.rooms[draggedRoomIndex];
                const newX = Math.max(0, Math.min(gridX - dragOffset.x, deck.grid_width - room.size[0]));
                const newY = Math.max(0, Math.min(gridY - dragOffset.y, deck.grid_height - room.size[1]));
                room.position = [newX, newY];
                render();
            }
        }

        function handleMouseUp(event) {
            if (isPanning) {
                isPanning = false;
                const svg = document.getElementById('mdsCanvas');
                if (svg) svg.style.cursor = panMode ? 'grab' : 'default';
                // Persist view when user releases pan
                saveViewToConfig();
                return;
            }
            if (isDragging) {
                isDragging = false;
                draggedRoomIndex = -1;
                draggedOutlineIndex = -1;
                saveToLocalStorage();
                renderRoomList();
                renderOutlineList();
            }
        }

        // Touch event handlers
        function handleTouchStart(event) {
            if (isMobileMoveMode) {
                legacy_handleTouchStart(event);
                return;
            }
            event.preventDefault();
            // ...existing code for pan/two-finger...
        }

        function handleTouchMove(event) {
            if (isMobileMoveMode) {
                legacy_handleTouchMove(event);
                return;
            }
            event.preventDefault();
            // ...existing code for pan/two-finger...
        }

        function handleTouchEnd(event) {
            if (isMobileMoveMode) {
                legacy_handleTouchEnd(event);
                return;
            }
            event.preventDefault();
            // ...existing code for pan/two-finger...
                const t1 = event.touches[1];
                const dx = t0.clientX - t1.clientX;
                const dy = t0.clientY - t1.clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Compute centroid and apply two-finger pan based on centroid delta
                const cx = (t0.clientX + t1.clientX) / 2;
                const cy = (t0.clientY + t1.clientY) / 2;
                if (twoFingerPanStart && pinchStartCentroid) {
                    const deltaX = cx - pinchStartCentroid.x;
                    const deltaY = cy - pinchStartCentroid.y;
                    view.panX = twoFingerPanStart.startPanX + deltaX;
                    view.panY = twoFingerPanStart.startPanY + deltaY;
                    // Update transform without clamping while user is gesturing
                    updateTransform();
                }

                // Pinch-to-zoom disabled by user preference; two-finger gestures only pan.

                return;
            }
            if (isPanning) {
                isPanning = false;
                saveViewToConfig();
                const svg = document.getElementById('mdsCanvas');
                if (svg) svg.style.cursor = panMode ? 'grab' : 'default';
                return;
            }

            // Only handle mouse up in move mode for drag end
            if (!isMobileMoveMode) {
                return;
            }
            const mouseEvent = new MouseEvent('mouseup', {});
            handleMouseUp(mouseEvent);
        }

        // Legacy (old-index) drag and touch handlers (kept separate)
        function legacy_handleMouseDown(event) {
            const deck = getCurrentDeck();
            const svg = document.getElementById('mdsCanvas');
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            // Convert from screen (transformed) coords back to SVG logical coords
            const svgX = mouseX / view.zoom;
            const svgY = mouseY / view.zoom;

            // Convert to grid coordinates (accounting for zoom/pan)
            const cellSize = config.grid_cell_size;
            const xBase = config.padding;
            const yBase = computeContentYBase(); // Header height

            const gridX = Math.floor((svgX - xBase) / cellSize);
            const gridY = Math.floor((svgY - yBase) / cellSize);
            
            // On mobile in move mode, ONLY drag the cycle-selected item
            // Ignore which object is actually touched - always drag the selected one
            if (isMobileMoveMode) {
                // Drag selected room
                if (selectedRoomIndex !== -1 && deck.rooms[selectedRoomIndex]) {
                    const room = deck.rooms[selectedRoomIndex];
                    if (room.position && room.size) {
                        draggedRoomIndex = selectedRoomIndex;
                        isDragging = true;
                        const [rx, ry] = room.position;
                        dragOffset.x = gridX - rx;
                        dragOffset.y = gridY - ry;
                        return;
                    }
                }
                
                // Drag selected outline
                if (selectedOutlineIndex !== -1 && config.manual_outlines && config.manual_outlines[selectedOutlineIndex]) {
                    const outline = config.manual_outlines[selectedOutlineIndex];
                    if (outline.position && outline.size) {
                        draggedOutlineIndex = selectedOutlineIndex;
                        isDragging = true;
                        const [ox, oy] = outline.position;
                        dragOffset.x = gridX - ox;
                        dragOffset.y = gridY - oy;
                        return;
                    }
                }
                
                // No selected item - do nothing
                return;
            }
            
            // Desktop behavior: Check rooms FIRST (higher priority than outlines)
            for (let i = deck.rooms.length - 1; i >= 0; i--) {
                const room = deck.rooms[i];
                if (room.position && room.size) {
                    const [rx, ry] = room.position;
                    const [rw, rh] = room.size;
                    
                    if (gridX >= rx && gridX < rx + rw && gridY >= ry && gridY < ry + rh) {
                        draggedRoomIndex = i;
                        isDragging = true;
                        dragOffset.x = gridX - rx;
                        dragOffset.y = gridY - ry;
                        selectedRoomIndex = i;
                        selectedOutlineIndex = -1; // Deselect outline when selecting room
                        renderRoomList();
                        renderOutlineList();
                        render();
                        return;
                    }
                }
            }
            
            // Check manual outlines (lower priority) - use global outlines
            if (config.manual_outlines && config.manual_outlines.length > 0) {
                for (let i = config.manual_outlines.length - 1; i >= 0; i--) {
                    const outline = config.manual_outlines[i];
                    // Only allow dragging if visible on current deck
                    if (outline.visible_on_decks && outline.visible_on_decks.includes(currentDeckIndex)) {
                        if (outline.position && outline.size) {
                            const [ox, oy] = outline.position;
                            const [ow, oh] = outline.size;
                            
                            if (gridX >= ox && gridX < ox + ow && gridY >= oy && gridY < oy + oh) {
                                draggedOutlineIndex = i;
                                isDragging = true;
                                dragOffset.x = gridX - ox;
                                dragOffset.y = gridY - oy;
                                selectedOutlineIndex = i;
                                selectedRoomIndex = -1; // Deselect room when selecting outline
                                renderOutlineList();
                                renderRoomList();
                                render();
                                return;
                            }
                        }
                    }
                }
            }
            
            // Clicked on empty space - deselect everything
            selectedRoomIndex = -1;
            selectedOutlineIndex = -1;
            renderRoomList();
            renderOutlineList();
            render();
        }

        function legacy_handleMouseMove(event) {
            if (!isDragging) return;
            
            const deck = getCurrentDeck();
            const svg = document.getElementById('mdsCanvas');
            const rect = svg.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const svgX = mouseX / view.zoom;
            const svgY = mouseY / view.zoom;

            const cellSize = config.grid_cell_size;
            const xBase = config.padding;
            const yBase = computeContentYBase();

            const gridX = Math.floor((svgX - xBase) / cellSize);
            const gridY = Math.floor((svgY - yBase) / cellSize);
            
            // Handle outline dragging
            if (draggedOutlineIndex !== -1) {
                const outline = config.manual_outlines[draggedOutlineIndex];
                // Allow outlines to flow off the grid (no boundary constraints)
                const newX = gridX - dragOffset.x;
                const newY = gridY - dragOffset.y;
                outline.position = [newX, newY];
                render();
                return;
            }
            
            // Handle room dragging
            if (draggedRoomIndex !== -1) {
                const room = deck.rooms[draggedRoomIndex];
                const newX = Math.max(0, Math.min(gridX - dragOffset.x, deck.grid_width - room.size[0]));
                const newY = Math.max(0, Math.min(gridY - dragOffset.y, deck.grid_height - room.size[1]));
                room.position = [newX, newY];
                render();
            }
        }

        function legacy_handleMouseUp(event) {
            if (isDragging) {
                isDragging = false;
                draggedRoomIndex = -1;
                draggedOutlineIndex = -1;
                saveToLocalStorage();
                renderRoomList();
                renderOutlineList();
            }
        }

        function legacy_handleTouchStart(event) {
            // Only allow touch interaction when in move mode
            if (!isMobileMoveMode) {
                return;
            }
            
            event.preventDefault();
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            legacy_handleMouseDown(mouseEvent);
        }

        function legacy_handleTouchMove(event) {
            // Only allow dragging in move mode
            if (!isMobileMoveMode) {
                return;
            }
            
            event.preventDefault();
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            legacy_handleMouseMove(mouseEvent);
        }

        function legacy_handleTouchEnd(event) {
            // Only handle mouse up in move mode
            if (!isMobileMoveMode) {
                return;
            }
            
            event.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            legacy_handleMouseUp(mouseEvent);
        }

        // Manual Outline Functions
        function addManualOutline() {
            // Initialize global outlines array if needed
            if (!config.manual_outlines) {
                config.manual_outlines = [];
            }
            
            openModal('Add Outline Shape', [
                { id: 'newOutlineName', label: 'Name/Label', type: 'text', value: 'Hull Section' },
                { 
                    id: 'newOutlineType', 
                    label: 'Shape Type', 
                    type: 'select', 
                    value: 'rect',
                    options: [
                        { value: 'rect', label: 'Rectangle' },
                        { value: 'ellipse', label: 'Ellipse' },
                        { value: 'triangle', label: 'Triangle' }
                    ]
                },
                { id: 'newOutlineWidth', label: 'Width (grid cells)', type: 'number', value: 4, min: 1, max: 30 },
                { id: 'newOutlineHeight', label: 'Height (grid cells)', type: 'number', value: 3, min: 1, max: 30 },
                { id: 'newOutlineColor', label: 'Color', type: 'color', value: currentPalette.background },
                { id: 'newOutlineZIndex', label: 'Z-Index (0=back, 100=front)', type: 'number', value: 0, min: 0, max: 100 }
            ],
            () => {
                // Save callback
                const newOutline = {
                    name: document.getElementById('newOutlineName').value || 'Hull Section',
                    type: document.getElementById('newOutlineType').value,
                    color: document.getElementById('newOutlineColor').value,
                    position: [2, 2],
                    size: [
                        parseInt(document.getElementById('newOutlineWidth').value),
                        parseInt(document.getElementById('newOutlineHeight').value)
                    ],
                    z_index: parseInt(document.getElementById('newOutlineZIndex').value) || 0,
                    rotation: 0,
                    show_border: true,
                    visible_on_decks: [currentDeckIndex] // Start visible only on current deck
                };
                
                config.manual_outlines.push(newOutline);
                saveToLocalStorage();
                renderOutlineList();
                render();
            });
        }

        function renderOutlineList() {
            const container = document.getElementById('outlineShapeList');
            
            // Use global outlines array
            const allOutlines = config.manual_outlines || [];
            
            container.innerHTML = allOutlines.length === 0 
                ? '<div style="text-align:center;color:#666;padding:10px;">No manual outlines</div>'
                : '';
            
            allOutlines.forEach((outline, index) => {
                const div = document.createElement('div');
                div.className = 'room-item';
                if (index === selectedOutlineIndex) {
                    div.classList.add('selected');
                }
                if (index === draggedOutlineIndex) {
                    div.classList.add('dragging');
                }
                
                // Show deck visibility info
                const visibleDecks = outline.visible_on_decks || [];
                const deckInfo = visibleDecks.length === 0 ? 'Hidden' :
                                 visibleDecks.length === config.decks.length ? 'All Decks' : 
                                 visibleDecks.length === 1 ? `Deck ${config.decks[visibleDecks[0]].number}` :
                                 `${visibleDecks.length} Decks`;
                
                div.innerHTML = `
                    <div class="room-item-header">
                        <div class="room-item-name">${outline.name || outline.type.toUpperCase()}</div>
                        <div class="room-color-indicator" style="background:${outline.color}"></div>
                    </div>
                    <div class="room-item-stats">${outline.type} ‚Ä¢ ${deckInfo}</div>
                `;
                
                // Double-click to edit (desktop)
                div.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editOutline(index);
                });
                
                // Single click to select
                div.addEventListener('click', (e) => {
                    if (e.detail === 1) { // Only on single click, not double
                        selectOutline(index);
                    }
                });
                
                // Long press to edit (mobile) - 500ms
                let longPressTimer = null;
                div.addEventListener('touchstart', (e) => {
                    longPressTimer = setTimeout(() => {
                        editOutline(index);
                    }, 500);
                });
                
                div.addEventListener('touchend', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
                
                div.addEventListener('touchmove', () => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
                
                container.appendChild(div);
            });
        }

        function selectOutline(index) {
            selectedOutlineIndex = selectedOutlineIndex === index ? -1 : index;
            renderOutlineList();
            render(); // Update canvas to show selection highlight
        }

        function editOutline(index) {
            const outline = config.manual_outlines[index];
            
            // Ensure visible_on_decks exists and is an array
            if (!outline.visible_on_decks || !Array.isArray(outline.visible_on_decks)) {
                outline.visible_on_decks = [currentDeckIndex];
            }
            
            console.log('Editing outline:', outline.name, 'visible_on_decks:', outline.visible_on_decks);
            
            // Build deck checkboxes HTML using table for proper alignment
            const deckCheckboxesHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    ${config.decks.map((d, i) => {
                        const isChecked = outline.visible_on_decks.includes(i);
                        return `
                            <tr>
                                <td style="padding: 5px 0; width: 30px;">
                                    <input type="checkbox" id="deck_visibility_${i}" value="${i}" ${isChecked ? 'checked' : ''} />
                                </td>
                                <td style="padding: 5px 0; color: #ccc; text-align: left;">
                                    <label for="deck_visibility_${i}" style="cursor: pointer;">Deck ${d.number}: ${d.name}</label>
                                </td>
                            </tr>
                        `;
                    }).join('')}
                </table>
            `;
            
            openModal('Edit Outline Shape', [
                { id: 'outlineName', label: 'Name/Label', type: 'text', value: outline.name || outline.type },
                { 
                    id: 'outlineType', 
                    label: 'Shape Type', 
                    type: 'select', 
                    value: outline.type,
                    options: [
                        { value: 'rect', label: 'Rectangle' },
                        { value: 'ellipse', label: 'Ellipse' },
                        { value: 'triangle', label: 'Triangle' }
                    ]
                },
                { id: 'outlineX', label: 'X Position (grid)', type: 'number', value: outline.position ? outline.position[0] : 0, min: -10, max: 40 },
                { id: 'outlineY', label: 'Y Position (grid)', type: 'number', value: outline.position ? outline.position[1] : 0, min: -10, max: 40 },
                { id: 'outlineWidth', label: 'Width (grid cells)', type: 'number', value: outline.size[0], min: 1, max: 30 },
                { id: 'outlineHeight', label: 'Height (grid cells)', type: 'number', value: outline.size[1], min: 1, max: 30 },
                { id: 'outlineColor', label: 'Color', type: 'color', value: outline.color },
                { id: 'outlineRotation', label: 'Rotation (degrees)', type: 'range', value: outline.rotation || 0, min: 0, max: 360, showInput: true },
                { 
                    id: 'outlineShowBorder', 
                    label: 'Show Border', 
                    type: 'select', 
                    value: outline.show_border === false ? 'false' : 'true',
                    options: [
                        { value: 'true', label: 'Yes' },
                        { value: 'false', label: 'No' }
                    ]
                },
                {
                    id: 'deckVisibility',
                    label: 'Visible on Decks:',
                    type: 'custom',
                    html: `<div style="max-height: 200px; overflow-y: auto; border: 1px solid #555; padding: 10px; border-radius: 4px; background: #0a0a0a;">${deckCheckboxesHTML}</div>`
                }
            ],
            () => {
                // Save callback
                outline.name = document.getElementById('outlineName').value || outline.type;
                outline.type = document.getElementById('outlineType').value;
                const x = parseInt(document.getElementById('outlineX').value);
                const y = parseInt(document.getElementById('outlineY').value);
                const width = parseInt(document.getElementById('outlineWidth').value);
                const height = parseInt(document.getElementById('outlineHeight').value);
                outline.position = [x, y];
                outline.size = [width, height];
                outline.color = document.getElementById('outlineColor').value;
                outline.rotation = parseInt(document.getElementById('outlineRotation_input').value) || 0;
                outline.show_border = document.getElementById('outlineShowBorder').value === 'true';
                
                // Update deck visibility
                const visibleDecks = [];
                config.decks.forEach((d, i) => {
                    const checkbox = document.getElementById(`deck_visibility_${i}`);
                    if (checkbox && checkbox.checked) {
                        visibleDecks.push(i);
                    }
                });
                outline.visible_on_decks = visibleDecks.length > 0 ? visibleDecks : [currentDeckIndex];
                
                console.log('Saved outline visibility:', outline.name, 'visible_on_decks:', outline.visible_on_decks);
                
                saveToLocalStorage();
                renderOutlineList();
                render();
            },
            () => {
                // Delete callback
                config.manual_outlines.splice(index, 1);
                selectedOutlineIndex = -1;
                saveToLocalStorage();
                renderOutlineList();
                render();
            },
            'üíæ Save',
            () => {
                // Duplicate callback
                duplicateOutlineToDecks(index);
            });
            
            // Add live preview for outline editing
            setTimeout(() => {
                const liveUpdateOutline = () => {
                    outline.name = document.getElementById('outlineName').value || outline.type;
                    outline.type = document.getElementById('outlineType').value;
                    const x = parseInt(document.getElementById('outlineX').value) || 0;
                    const y = parseInt(document.getElementById('outlineY').value) || 0;
                    const width = parseInt(document.getElementById('outlineWidth').value) || outline.size[0];
                    const height = parseInt(document.getElementById('outlineHeight').value) || outline.size[1];
                    outline.position = [x, y];
                    outline.size = [width, height];
                    outline.color = document.getElementById('outlineColor').value;
                    outline.rotation = parseInt(document.getElementById('outlineRotation_input').value) || 0;
                    outline.show_border = document.getElementById('outlineShowBorder').value === 'true';
                    render();
                };
                
                document.getElementById('outlineName').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineType').addEventListener('change', liveUpdateOutline);
                document.getElementById('outlineX').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineY').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineWidth').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineHeight').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineColor').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineRotation').addEventListener('input', liveUpdateOutline);
                document.getElementById('outlineShowBorder').addEventListener('change', liveUpdateOutline);
            }, 100);
        }

        function duplicateOutlineToDecks(outlineIndex) {
            const outline = config.manual_outlines[outlineIndex];
            
            // Create deck selection checkboxes
            const deckOptions = config.decks.map((deck, index) => {
                if (index === currentDeckIndex) return null; // Skip current deck
                return `
                    <div style="margin: 10px 0;">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="outline_deck_${index}" value="${index}" />
                            <span>Deck ${deck.number}: ${deck.name}</span>
                        </label>
                    </div>
                `;
            }).filter(Boolean).join('');
            
            if (!deckOptions) {
                alert('No other decks available. Add more decks first!');
                return;
            }
            
            const modalBody = document.getElementById('modalBody');
            modalBody.innerHTML = `
                <p style="color: #ccc; margin-bottom: 15px;">Select which decks to duplicate outline shape "${outline.name || outline.type}" to:</p>
                ${deckOptions}
            `;
            
            // Update modal title and buttons
            document.getElementById('modalTitle').textContent = 'Duplicate Outline Shape to Decks';
            const deleteBtn = document.getElementById('modalDeleteBtn');
            deleteBtn.style.display = 'none';
            const duplicateBtn = document.getElementById('modalDuplicateBtn');
            if (duplicateBtn) duplicateBtn.style.display = 'none';
            
            const saveBtn = document.getElementById('modalSaveBtn');
            saveBtn.textContent = 'üìã Duplicate';
            
            modalContext = {
                onSave: () => {
                    // Get selected decks
                    const selectedDecks = [];
                    config.decks.forEach((deck, index) => {
                        const checkbox = document.getElementById(`outline_deck_${index}`);
                        if (checkbox && checkbox.checked) {
                            selectedDecks.push(index);
                        }
                    });
                    
                    if (selectedDecks.length === 0) {
                        alert('Please select at least one deck!');
                        return;
                    }
                    
                    // Duplicate outline to selected decks
                    selectedDecks.forEach(deckIndex => {
                        const outlineCopy = JSON.parse(JSON.stringify(outline)); // Deep clone
                        // Update visible_on_decks to include the new deck
                        if (!outlineCopy.visible_on_decks) {
                            outlineCopy.visible_on_decks = [deckIndex];
                        } else {
                            // Add new deck to visibility list if not already there
                            if (!outlineCopy.visible_on_decks.includes(deckIndex)) {
                                outlineCopy.visible_on_decks.push(deckIndex);
                            }
                        }
                        config.manual_outlines.push(outlineCopy);
                    });
                    
                    saveToLocalStorage();
                    alert(`Outline shape duplicated to ${selectedDecks.length} deck(s)!`);
                    renderOutlineList();
                    render();
                },
                onDelete: null,
                onDuplicate: null
            };
            
            document.getElementById('modalOverlay').classList.add('active');
        }

        // Export Functions
        function exportShip() {
            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${config.name.replace(/\s+/g, '_')}_ship.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importShip() {
            document.getElementById('shipFileInput').click();
        }

        function editCustomPalette() {
            const custom = COLOR_PALETTES.custom;
            
            openModal('Edit Custom Palette', [
                { id: 'customBackground', label: 'Background', type: 'color', value: custom.background },
                { id: 'customText', label: 'Text', type: 'color', value: custom.text },
                { id: 'customBorder', label: 'Border', type: 'color', value: custom.border },
                { id: 'customGrid', label: 'Grid', type: 'color', value: custom.grid },
                { id: 'customHull', label: 'Hull Outline', type: 'color', value: custom.hull },
                { id: 'customAccent1', label: 'Accent 1', type: 'color', value: custom.accent1 },
                { id: 'customAccent2', label: 'Accent 2', type: 'color', value: custom.accent2 },
                { id: 'customColor1', label: 'Room Color 1', type: 'color', value: custom.colors.COLOR_1 },
                { id: 'customColor2', label: 'Room Color 2', type: 'color', value: custom.colors.COLOR_2 },
                { id: 'customColor3', label: 'Room Color 3', type: 'color', value: custom.colors.COLOR_3 },
                { id: 'customColor4', label: 'Room Color 4', type: 'color', value: custom.colors.COLOR_4 },
                { id: 'customColor5', label: 'Room Color 5', type: 'color', value: custom.colors.COLOR_5 },
                { id: 'customColor6', label: 'Room Color 6', type: 'color', value: custom.colors.COLOR_6 },
                { id: 'customColor7', label: 'Room Color 7', type: 'color', value: custom.colors.COLOR_7 },
                { id: 'customColor8', label: 'Room Color 8', type: 'color', value: custom.colors.COLOR_8 },
                { id: 'customColor9', label: 'Room Color 9', type: 'color', value: custom.colors.COLOR_9 }
            ],
            () => {
                // Save callback
                custom.background = document.getElementById('customBackground').value;
                custom.text = document.getElementById('customText').value;
                custom.border = document.getElementById('customBorder').value;
                custom.grid = document.getElementById('customGrid').value;
                custom.hull = document.getElementById('customHull').value;
                custom.accent1 = document.getElementById('customAccent1').value;
                custom.accent2 = document.getElementById('customAccent2').value;
                custom.colors.COLOR_1 = document.getElementById('customColor1').value;
                custom.colors.COLOR_2 = document.getElementById('customColor2').value;
                custom.colors.COLOR_3 = document.getElementById('customColor3').value;
                custom.colors.COLOR_4 = document.getElementById('customColor4').value;
                custom.colors.COLOR_5 = document.getElementById('customColor5').value;
                custom.colors.COLOR_6 = document.getElementById('customColor6').value;
                custom.colors.COLOR_7 = document.getElementById('customColor7').value;
                custom.colors.COLOR_8 = document.getElementById('customColor8').value;
                custom.colors.COLOR_9 = document.getElementById('customColor9').value;
                
                currentPalette = custom;
                applyColorPalette();
                saveToLocalStorage();
                render();
            },
            null);
            
            // Add live preview for palette editing
            setTimeout(() => {
                const liveUpdatePalette = () => {
                    custom.background = document.getElementById('customBackground').value;
                    custom.text = document.getElementById('customText').value;
                    custom.border = document.getElementById('customBorder').value;
                    custom.grid = document.getElementById('customGrid').value;
                    custom.hull = document.getElementById('customHull').value;
                    custom.accent1 = document.getElementById('customAccent1').value;
                    custom.accent2 = document.getElementById('customAccent2').value;
                    custom.colors.COLOR_1 = document.getElementById('customColor1').value;
                    custom.colors.COLOR_2 = document.getElementById('customColor2').value;
                    custom.colors.COLOR_3 = document.getElementById('customColor3').value;
                    custom.colors.COLOR_4 = document.getElementById('customColor4').value;
                    custom.colors.COLOR_5 = document.getElementById('customColor5').value;
                    custom.colors.COLOR_6 = document.getElementById('customColor6').value;
                    custom.colors.COLOR_7 = document.getElementById('customColor7').value;
                    custom.colors.COLOR_8 = document.getElementById('customColor8').value;
                    custom.colors.COLOR_9 = document.getElementById('customColor9').value;
                    
                    currentPalette = custom;
                    applyColorPalette();
                    render();
                };
                
                ['customBackground', 'customText', 'customBorder', 'customGrid', 'customHull', 
                 'customAccent1', 'customAccent2', 'customColor1', 'customColor2', 'customColor3',
                 'customColor4', 'customColor5', 'customColor6', 'customColor7', 'customColor8', 'customColor9']
                    .forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.addEventListener('input', liveUpdatePalette);
                    });
            }, 100);
        }

        function exportSettings() {
            const settings = {
                grid_cell_size: config.grid_cell_size,
                padding: config.padding,
                font_size: config.font_size,
                text_color: config.text_color,
                text_shadow: config.text_shadow,
                ship_outline_color: config.ship_outline_color,
                show_arches: config.show_arches,
                show_grid: config.show_grid,
                outline_style: config.outline_style,
                auto_outline: config.auto_outline,
                outline_padding: config.outline_padding,
                color_palette: config.color_palette,
                manual_outline_mode: config.manual_outline_mode,
                custom_palette: COLOR_PALETTES.custom
            };
            const json = JSON.stringify(settings, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mds_settings.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importSettings() {
            document.getElementById('settingsFileInput').click();
        }

        function handleShipImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    config = imported;
                    currentDeckIndex = 0;
                    selectedRoomIndex = -1;
                    
                    // Restore custom palette if it exists
                    if (config.custom_palette) {
                        COLOR_PALETTES.custom = config.custom_palette;
                    }
                    
                    currentPalette = COLOR_PALETTES[config.color_palette || 'lcars'];
                    saveToLocalStorage();
                    syncUIFromConfig();
                    renderDeckTabs();
                    renderRoomList();
                    render();
                    alert('Ship imported successfully!');
                } catch (error) {
                    alert('Error importing ship: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function handleSettingsImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // Restore custom palette if it exists
                    if (imported.custom_palette) {
                        COLOR_PALETTES.custom = imported.custom_palette;
                    }
                    
                    // Apply settings to config
                    Object.assign(config, imported);
                    currentPalette = COLOR_PALETTES[config.color_palette || 'lcars'];
                    saveToLocalStorage();
                    syncUIFromConfig();
                    render();
                    alert('Settings imported successfully!');
                } catch (error) {
                    alert('Error importing settings: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportSVG() {
            const svg = document.getElementById('mdsCanvas');
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const deck = getCurrentDeck();
            a.href = url;
            a.download = `${config.name.replace(/\s+/g, '_')}_deck${deck.number}_${deck.name.replace(/\s+/g, '_')}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportPNG() {
            const svg = document.getElementById('mdsCanvas');
            const svgData = new XMLSerializer().serializeToString(svg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const deck = getCurrentDeck();
                    a.href = url;
                    a.download = `${config.name.replace(/\s+/g, '_')}_deck${deck.number}_${deck.name.replace(/\s+/g, '_')}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            };
            
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        // Space Engineers LCD Text Export
        function exportSELCD() {
            try {
                console.log('SE LCD Export started...');
                const svg = document.getElementById('mdsCanvas');
                if (!svg) {
                    alert('Error: Canvas not found!');
                    return;
                }
                
                // Store SVG data globally for regeneration
                window.currentSVGData = new XMLSerializer().serializeToString(svg);
                
                // Show modal and generate with default resolution
                document.getElementById('seLCDModal').style.display = 'flex';
                regenerateSELCDText();
                
            } catch (err) {
                console.error('Error in exportSELCD:', err);
                alert('Error: ' + err.message);
            }
        }

        function regenerateSELCDText() {
            try {
                const resolutionSelect = document.getElementById('seLCDResolution').value;
                const tileSize = 178; // Standard LCD size
                let gridSizeX, gridSizeY;
                
                // Show/hide custom grid input
                const customGridDiv = document.getElementById('seLCDCustomGrid');
                if (resolutionSelect === 'custom') {
                    customGridDiv.style.display = 'block';
                    gridSizeX = parseInt(document.getElementById('seLCDCustomX').value) || 2;
                    gridSizeY = parseInt(document.getElementById('seLCDCustomY').value) || 2;
                } else {
                    customGridDiv.style.display = 'none';
                    const resolution = parseInt(resolutionSelect);
                    gridSizeX = Math.ceil(resolution / tileSize);
                    gridSizeY = Math.ceil(resolution / tileSize);
                }
                
                console.log(`Regenerating with grid: ${gridSizeX}x${gridSizeY}`);
                
                // Update grid info
                const gridInfo = document.getElementById('seLCDGridInfo');
                if (gridSizeX === 1 && gridSizeY === 1) {
                    gridInfo.textContent = `Single LCD panel (178x178)`;
                } else {
                    gridInfo.textContent = `Requires ${gridSizeX}x${gridSizeY} grid = ${gridSizeX * gridSizeY} LCD panels`;
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    try {
                        console.log('Image loaded, converting...');
                        
                        // Calculate actual grid dimensions in pixels
                        const gridPixelWidth = gridSizeX * tileSize;
                        const gridPixelHeight = gridSizeY * tileSize;
                        
                        canvas.width = gridPixelWidth;
                        canvas.height = gridPixelHeight;
                        
                        // Fill with black background
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, gridPixelWidth, gridPixelHeight);
                        
                        // Calculate scaling to fit image while maintaining aspect ratio
                        // Use the grid dimensions, not the original resolution
                        const scale = Math.min(gridPixelWidth / img.width, gridPixelHeight / img.height);
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        const offsetX = (gridPixelWidth - scaledWidth) / 2;
                        const offsetY = (gridPixelHeight - scaledHeight) / 2;
                        
                        // Draw image centered in the grid
                        ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                        
                        // Get full pixel data from the grid
                        const imageData = ctx.getImageData(0, 0, gridPixelWidth, gridPixelHeight);
                        const pixels = imageData.data;
                        
                        // Generate tiles
                        window.seLCDTiles = [];
                        
                        for (let tileY = 0; tileY < gridSizeY; tileY++) {
                            for (let tileX = 0; tileX < gridSizeX; tileX++) {
                                let tileText = '';
                                
                                // Extract 178x178 tile from the full image
                                for (let y = 0; y < tileSize; y++) {
                                    for (let x = 0; x < tileSize; x++) {
                                        const sourceX = tileX * tileSize + x;
                                        const sourceY = tileY * tileSize + y;
                                        
                                        // Always within bounds since we sized canvas to grid
                                        const idx = (sourceY * gridPixelWidth + sourceX) * 4;
                                        const r = pixels[idx];
                                        const g = pixels[idx + 1];
                                        const b = pixels[idx + 2];
                                        
                                        // Convert RGB to 3-bit color
                                        const r3bit = Math.round(r / 255 * 7);
                                        const g3bit = Math.round(g / 255 * 7);
                                        const b3bit = Math.round(b / 255 * 7);
                                        
                                        // Encode as SE monospace character
                                        const charCode = 0xE100 + (r3bit << 6) + (g3bit << 3) + b3bit;
                                        tileText += String.fromCharCode(charCode);
                                    }
                                    if (y < tileSize - 1) {
                                        tileText += '\n';
                                    }
                                }
                                
                                // Add metadata footer
                                const deck = getCurrentDeck();
                                const gridDesc = resolutionSelect === 'custom' ? `${gridSizeX}x${gridSizeY}` : `${resolutionSelect}x${resolutionSelect}`;
                                tileText += `\nMDS: ${config.name} D${deck.number} [${gridDesc}] Tile<${tileX},${tileY}>`;
                                
                                window.seLCDTiles.push({
                                    x: tileX,
                                    y: tileY,
                                    text: tileText
                                });
                            }
                        }
                        
                        console.log(`Generated ${window.seLCDTiles.length} tiles`);
                        
                        // Show/hide tile selector based on grid size
                        const tileSelector = document.getElementById('seLCDTileSelector');
                        if (gridSizeX === 1 && gridSizeY === 1) {
                            tileSelector.style.display = 'none';
                            document.getElementById('seLCDInstructionTile').style.display = 'none';
                            showSELCDModal(window.seLCDTiles[0].text);
                        } else {
                            tileSelector.style.display = 'block';
                            document.getElementById('seLCDInstructionTile').style.display = 'list-item';
                            
                            // Generate tile tabs
                            const tileTabs = document.getElementById('seLCDTileTabs');
                            tileTabs.innerHTML = '';
                            
                            for (let tileY = 0; tileY < gridSizeY; tileY++) {
                                for (let tileX = 0; tileX < gridSizeX; tileX++) {
                                    const tileIndex = tileY * gridSizeX + tileX;
                                    const btn = document.createElement('button');
                                    btn.className = 'btn btn-secondary';
                                    btn.textContent = `<${tileX},${tileY}>`;
                                    btn.style.minWidth = '70px';
                                    btn.onclick = () => selectSELCDTile(tileIndex, gridSizeX);
                                    if (tileIndex === 0) {
                                        btn.classList.add('active-tile');
                                        btn.style.background = 'var(--lcars-orange)';
                                        btn.style.color = '#000';
                                    }
                                    tileTabs.appendChild(btn);
                                }
                                // Add line break after each row
                                tileTabs.appendChild(document.createElement('br'));
                            }
                            
                            // Show first tile
                            selectSELCDTile(0, gridSizeX);
                        }
                        
                    } catch (err) {
                        console.error('Error during conversion:', err);
                        alert('Error converting image: ' + err.message);
                    }
                };
                
                img.onerror = (err) => {
                    console.error('Error loading image:', err);
                    alert('Error loading image for conversion');
                };
                
                img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(window.currentSVGData)));
                console.log('Image source set, waiting for load...');
            } catch (err) {
                console.error('Error in regenerateSELCDText:', err);
                alert('Error: ' + err.message);
            }
        }
        
        function selectSELCDTile(index, gridSizeX) {
            const tile = window.seLCDTiles[index];
            
            // Update active tile button
            const tileTabs = document.getElementById('seLCDTileTabs');
            const buttons = tileTabs.getElementsByTagName('button');
            for (let i = 0; i < buttons.length; i++) {
                if (i === index) {
                    buttons[i].classList.add('active-tile');
                    buttons[i].style.background = 'var(--lcars-orange)';
                    buttons[i].style.color = '#000';
                } else {
                    buttons[i].classList.remove('active-tile');
                    buttons[i].style.background = '';
                    buttons[i].style.color = '';
                }
            }
            
            // Update text area and label
            document.getElementById('seLCDPreviewLabel').textContent = `LCD Text Preview - Tile <${tile.x},${tile.y}>:`;
            showSELCDModal(tile.text);
        }

        function showSELCDModal(lcdText) {
            // Store text globally for copy function
            window.currentSELCDText = lcdText;
            
            // Populate the modal
            document.getElementById('seLCDTextArea').value = lcdText;
            document.getElementById('seLCDStringLength').innerHTML = `<em>String Length: ${lcdText.length} characters</em>`;
            
            // Show modal
            document.getElementById('seLCDModal').style.display = 'flex';
        }
        
        function closeSELCDModal() {
            document.getElementById('seLCDModal').style.display = 'none';
        }

        function copySELCDText() {
            const textarea = document.getElementById('seLCDTextArea');
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                navigator.clipboard.writeText(textarea.value).then(() => {
                    alert('‚úÖ Copied to clipboard! Now paste it into your Space Engineers LCD panel.');
                }).catch(err => {
                    // Fallback for older browsers
                    document.execCommand('copy');
                    alert('‚úÖ Copied to clipboard! Now paste it into your Space Engineers LCD panel.');
                });
            } catch (err) {
                alert('‚ùå Failed to copy to clipboard. Please select the text manually and copy it.');
            }
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });
        
        // Also trigger on window load as backup
        window.addEventListener('load', () => {
            applyColorPalette(); // Re-apply palette to ensure CSS variables are set
            render();
        });
        // Window resize handler left as-is; no placeholder to sync.
    </script>
</body>
</html>
